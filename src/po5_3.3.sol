// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*

  Thu·∫≠t to√°n:

  ### **üìå Gi·∫£i ph√°p Smart Contract cho "Power of 5"**  
  D∆∞·ªõi ƒë√¢y l√† gi·∫£i ph√°p ƒë·ªÉ tri·ªÉn khai h·ªá th·ªëng **Power of 5 Compensation Plan** tr√™n Blockchain, ƒë·∫£m b·∫£o 7 ph·∫ßn th∆∞·ªüng ho·∫°t ƒë·ªông ch√≠nh x√°c:

  ‚úÖ Chi tr·∫£ ƒë√∫ng Activation Fee ($10 cho upline)

  ‚úÖ T√≠nh to√°n ch√≠nh x√°c hoa h·ªìng b√°n l·∫ª (20% BP), 4% cho DAO, 1% cho showroom g·∫ßn user nh·∫•t

  ‚úÖ √Åp d·ª•ng Unilevel Bonus (10%-5%-5%-5%-5%)

  ‚úÖ T√≠nh PGB (2%) cho tuy·∫øn d∆∞·ªõi ch∆∞a ƒë·∫°t STL

  ‚úÖ T√≠nh GB (3%) cho tuy·∫øn d∆∞·ªõi ƒë√£ ƒë·∫°t STL (n·∫øu ƒë·∫°t Director tr·ªü l√™n)

  ‚úÖ Gi·ªõi h·∫°n t·ªëi ƒëa 50% t·ª´ ch√¢n m·∫°nh

  ‚úÖ T√≠ch h·ª£p Agent Program & chia 32.5% TGBP v√†o Unilevel

  B√™n c·∫°nh ƒë√≥:

  ‚úÖ **C·∫≠p nh·∫≠t tr·∫°ng th√°i Active & TeamBP theo th·ª© t·ª± ch√≠nh x√°c**  

  ‚úÖ **Batch processing m·ªói gi·ªù gi√∫p c·∫≠p nh·∫≠t h·ªá th·ªëng ch√≠nh x√°c & ti·∫øt ki·ªám gas**  

  üìå Quy tr√¨nh:

  1. B·∫Øt ƒë·∫ßu t·ª´ c√°c leafNodes (tuy·∫øn d∆∞·ªõi c√πng, kh√¥ng c√≥ con).

  2. T·ª´ng node c·∫≠p nh·∫≠t d·ªØ li·ªáu cho cha, cho ƒë·∫øn khi ƒë·∫°t root.

  3. M·ªói node ch·ªâ t√≠nh to√°n sau khi t·∫•t c·∫£ con ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.

  4. M·ªói 24h, c·∫≠p nh·∫≠t `generationRank` t·ª´ root xu·ªëng l√° cho h·ªá th·ªëng.

*/

// Import c√°c h·ª£p ƒë·ªìng ERC20 v√† Ownable t·ª´ OpenZeppelin ƒë·ªÉ qu·∫£n l√Ω token v√† ki·ªÉm so√°t quy·ªÅn
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";



/**
 * @notice Solidity library offering basic trigonometry functions where inputs and outputs are
 * integers. Inputs are specified in radians scaled by 1e18, and similarly outputs are scaled by 1e18.
 *
 * This implementation is based off the Solidity trigonometry library written by Lefteris Karapetsas
 * which can be found here: https://github.com/Sikorkaio/sikorka/blob/e75c91925c914beaedf4841c0336a806f2b5f66d/contracts/trigonometry.sol
 *
 * Compared to Lefteris' implementation, this version makes the following changes:
 *   - Uses a 32 bits instead of 16 bits for improved accuracy
 *   - Updated for Solidity 0.8.x
 *   - Various gas optimizations
 *   - Change inputs/outputs to standard trig format (scaled by 1e18) instead of requiring the
 *     integer format used by the algorithm
 *
 * Lefertis' implementation is based off Dave Dribin's trigint C library
 *     http://www.dribin.org/dave/trigint/
 *
 * Which in turn is based from a now deleted article which can be found in the Wayback Machine:
 *     http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html
 */
library Trigonometry {
  // Table index into the trigonometric table
  uint256 constant INDEX_WIDTH        = 8;
  // Interpolation between successive entries in the table
  uint256 constant INTERP_WIDTH       = 16;
  uint256 constant INDEX_OFFSET       = 28 - INDEX_WIDTH;
  uint256 constant INTERP_OFFSET      = INDEX_OFFSET - INTERP_WIDTH;
  uint32  constant ANGLES_IN_CYCLE    = 1073741824;
  uint32  constant QUADRANT_HIGH_MASK = 536870912;
  uint32  constant QUADRANT_LOW_MASK  = 268435456;
  uint256 constant SINE_TABLE_SIZE    = 256;

  // Pi as an 18 decimal value, which is plenty of accuracy: "For JPL's highest accuracy calculations, which are for
  // interplanetary navigation, we use 3.141592653589793: https://www.jpl.nasa.gov/edu/news/2016/3/16/how-many-decimals-of-pi-do-we-really-need/
  uint256 constant PI          = 3141592653589793238;
  uint256 constant TWO_PI      = 2 * PI;
  uint256 constant PI_OVER_TWO = PI / 2;

  // The constant sine lookup table was generated by generate_trigonometry.py. We must use a constant
  // bytes array because constant arrays are not supported in Solidity. Each entry in the lookup
  // table is 4 bytes. Since we're using 32-bit parameters for the lookup table, we get a table size
  // of 2^(32/4) + 1 = 257, where the first and last entries are equivalent (hence the table size of
  // 256 defined above)
  uint8   constant entry_bytes = 4; // each entry in the lookup table is 4 bytes
  uint256 constant entry_mask  = ((1 << 8*entry_bytes) - 1); // mask used to cast bytes32 -> lookup table entry
  bytes   constant sin_table   = hex"00_00_00_00_00_c9_0f_88_01_92_1d_20_02_5b_26_d7_03_24_2a_bf_03_ed_26_e6_04_b6_19_5d_05_7f_00_35_06_47_d9_7c_07_10_a3_45_07_d9_5b_9e_08_a2_00_9a_09_6a_90_49_0a_33_08_bc_0a_fb_68_05_0b_c3_ac_35_0c_8b_d3_5e_0d_53_db_92_0e_1b_c2_e4_0e_e3_87_66_0f_ab_27_2b_10_72_a0_48_11_39_f0_cf_12_01_16_d5_12_c8_10_6e_13_8e_db_b1_14_55_76_b1_15_1b_df_85_15_e2_14_44_16_a8_13_05_17_6d_d9_de_18_33_66_e8_18_f8_b8_3c_19_bd_cb_f3_1a_82_a0_25_1b_47_32_ef_1c_0b_82_6a_1c_cf_8c_b3_1d_93_4f_e5_1e_56_ca_1e_1f_19_f9_7b_1f_dc_dc_1b_20_9f_70_1c_21_61_b3_9f_22_23_a4_c5_22_e5_41_af_23_a6_88_7e_24_67_77_57_25_28_0c_5d_25_e8_45_b6_26_a8_21_85_27_67_9d_f4_28_26_b9_28_28_e5_71_4a_29_a3_c4_85_2a_61_b1_01_2b_1f_34_eb_2b_dc_4e_6f_2c_98_fb_ba_2d_55_3a_fb_2e_11_0a_62_2e_cc_68_1e_2f_87_52_62_30_41_c7_60_30_fb_c5_4d_31_b5_4a_5d_32_6e_54_c7_33_26_e2_c2_33_de_f2_87_34_96_82_4f_35_4d_90_56_36_04_1a_d9_36_ba_20_13_37_6f_9e_46_38_24_93_b0_38_d8_fe_93_39_8c_dd_32_3a_40_2d_d1_3a_f2_ee_b7_3b_a5_1e_29_3c_56_ba_70_3d_07_c1_d5_3d_b8_32_a5_3e_68_0b_2c_3f_17_49_b7_3f_c5_ec_97_40_73_f2_1d_41_21_58_9a_41_ce_1e_64_42_7a_41_d0_43_25_c1_35_43_d0_9a_ec_44_7a_cd_50_45_24_56_bc_45_cd_35_8f_46_75_68_27_47_1c_ec_e6_47_c3_c2_2e_48_69_e6_64_49_0f_57_ee_49_b4_15_33_4a_58_1c_9d_4a_fb_6c_97_4b_9e_03_8f_4c_3f_df_f3_4c_e1_00_34_4d_81_62_c3_4e_21_06_17_4e_bf_e8_a4_4f_5e_08_e2_4f_fb_65_4c_50_97_fc_5e_51_33_cc_94_51_ce_d4_6e_52_69_12_6e_53_02_85_17_53_9b_2a_ef_54_33_02_7d_54_ca_0a_4a_55_60_40_e2_55_f5_a4_d2_56_8a_34_a9_57_1d_ee_f9_57_b0_d2_55_58_42_dd_54_58_d4_0e_8c_59_64_64_97_59_f3_de_12_5a_82_79_99_5b_10_35_ce_5b_9d_11_53_5c_29_0a_cc_5c_b4_20_df_5d_3e_52_36_5d_c7_9d_7b_5e_50_01_5d_5e_d7_7c_89_5f_5e_0d_b2_5f_e3_b3_8d_60_68_6c_ce_60_ec_38_2f_61_6f_14_6b_61_f1_00_3e_62_71_fa_68_62_f2_01_ac_63_71_14_cc_63_ef_32_8f_64_6c_59_bf_64_e8_89_25_65_63_bf_91_65_dd_fb_d2_66_57_3c_bb_66_cf_81_1f_67_46_c7_d7_67_bd_0f_bc_68_32_57_aa_68_a6_9e_80_69_19_e3_1f_69_8c_24_6b_69_fd_61_4a_6a_6d_98_a3_6a_dc_c9_64_6b_4a_f2_78_6b_b8_12_d0_6c_24_29_5f_6c_8f_35_1b_6c_f9_34_fb_6d_62_27_f9_6d_ca_0d_14_6e_30_e3_49_6e_96_a9_9c_6e_fb_5f_11_6f_5f_02_b1_6f_c1_93_84_70_23_10_99_70_83_78_fe_70_e2_cb_c5_71_41_08_04_71_9e_2c_d1_71_fa_39_48_72_55_2c_84_72_af_05_a6_73_07_c3_cf_73_5f_66_25_73_b5_eb_d0_74_0b_53_fa_74_5f_9d_d0_74_b2_c8_83_75_04_d3_44_75_55_bd_4b_75_a5_85_ce_75_f4_2c_0a_76_41_af_3c_76_8e_0e_a5_76_d9_49_88_77_23_5f_2c_77_6c_4e_da_77_b4_17_df_77_fa_b9_88_78_40_33_28_78_84_84_13_78_c7_ab_a1_79_09_a9_2c_79_4a_7c_11_79_8a_23_b0_79_c8_9f_6d_7a_05_ee_ac_7a_42_10_d8_7a_7d_05_5a_7a_b6_cb_a3_7a_ef_63_23_7b_26_cb_4e_7b_5d_03_9d_7b_92_0b_88_7b_c5_e2_8f_7b_f8_88_2f_7c_29_fb_ed_7c_5a_3d_4f_7c_89_4b_dd_7c_b7_27_23_7c_e3_ce_b1_7d_0f_42_17_7d_39_80_eb_7d_62_8a_c5_7d_8a_5f_3f_7d_b0_fd_f7_7d_d6_66_8e_7d_fa_98_a7_7e_1d_93_e9_7e_3f_57_fe_7e_5f_e4_92_7e_7f_39_56_7e_9d_55_fb_7e_ba_3a_38_7e_d5_e5_c5_7e_f0_58_5f_7f_09_91_c3_7f_21_91_b3_7f_38_57_f5_7f_4d_e4_50_7f_62_36_8e_7f_75_4e_7f_7f_87_2b_f2_7f_97_ce_bc_7f_a7_36_b3_7f_b5_63_b2_7f_c2_55_95_7f_ce_0c_3d_7f_d8_87_8d_7f_e1_c7_6a_7f_e9_cb_bf_7f_f0_94_77_7f_f6_21_81_7f_fa_72_d0_7f_fd_88_59_7f_ff_62_15_7f_ff_ff_ff";

  /**
   * @notice Return the sine of a value, specified in radians scaled by 1e18
   * @dev This algorithm for converting sine only uses integer values, and it works by dividing the
   * circle into 30 bit angles, i.e. there are 1,073,741,824 (2^30) angle units, instead of the
   * standard 360 degrees (2pi radians). From there, we get an output in range -2,147,483,647 to
   * 2,147,483,647, (which is the max value of an int32) which is then converted back to the standard
   * range of -1 to 1, again scaled by 1e18
   * @param _angle Angle to convert
   * @return Result scaled by 1e18
   */
  function sin(uint256 _angle) internal pure returns (int256) {
    unchecked {
      // Convert angle from from arbitrary radian value (range of 0 to 2pi) to the algorithm's range
      // of 0 to 1,073,741,824
      _angle = ANGLES_IN_CYCLE * (_angle % TWO_PI) / TWO_PI;

      // Apply a mask on an integer to extract a certain number of bits, where angle is the integer
      // whose bits we want to get, the width is the width of the bits (in bits) we want to extract,
      // and the offset is the offset of the bits (in bits) we want to extract. The result is an
      // integer containing _width bits of _value starting at the offset bit
      uint256 interp = (_angle >> INTERP_OFFSET) & ((1 << INTERP_WIDTH) - 1);
      uint256 index  = (_angle >> INDEX_OFFSET)  & ((1 << INDEX_WIDTH)  - 1);

      // The lookup table only contains data for one quadrant (since sin is symmetric around both
      // axes), so here we figure out which quadrant we're in, then we lookup the values in the
      // table then modify values accordingly
      bool is_odd_quadrant      = (_angle & QUADRANT_LOW_MASK)  == 0;
      bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;

      if (!is_odd_quadrant) {
        index = SINE_TABLE_SIZE - 1 - index;
      }

      bytes memory table = sin_table;
      // We are looking for two consecutive indices in our lookup table
      // Since EVM is left aligned, to read n bytes of data from idx i, we must read from `i * data_len` + `n`
      // therefore, to read two entries of size entry_bytes `index * entry_bytes` + `entry_bytes * 2`
      uint256 offset1_2 = (index + 2) * entry_bytes;

      // This following snippet will function for any entry_bytes <= 15
      uint256 x1_2; assembly {
        // mload will grab one word worth of bytes (32), as that is the minimum size in EVM
        x1_2 := mload(add(table, offset1_2))
      }

      // We now read the last two numbers of size entry_bytes from x1_2
      // in example: entry_bytes = 4; x1_2 = 0x00...12345678abcdefgh
      // therefore: entry_mask = 0xFFFFFFFF

      // 0x00...12345678abcdefgh >> 8*4 = 0x00...12345678
      // 0x00...12345678 & 0xFFFFFFFF = 0x12345678
      uint256 x1 = x1_2 >> 8*entry_bytes & entry_mask;
      // 0x00...12345678abcdefgh & 0xFFFFFFFF = 0xabcdefgh
      uint256 x2 = x1_2 & entry_mask;

      // Approximate angle by interpolating in the table, accounting for the quadrant
      uint256 approximation = ((x2 - x1) * interp) >> INTERP_WIDTH;
      int256 sine = is_odd_quadrant ? int256(x1) + int256(approximation) : int256(x2) - int256(approximation);
      if (is_negative_quadrant) {
        sine *= -1;
      }

      // Bring result from the range of -2,147,483,647 through 2,147,483,647 to -1e18 through 1e18.
      // This can never overflow because sine is bounded by the above values
      return sine * 1e18 / 2_147_483_647;
    }
  }

  /**
   * @notice Return the cosine of a value, specified in radians scaled by 1e18
   * @dev This is identical to the sin() method, and just computes the value by delegating to the
   * sin() method using the identity cos(x) = sin(x + pi/2)
   * @dev Overflow when `angle + PI_OVER_TWO > type(uint256).max` is ok, results are still accurate
   * @param _angle Angle to convert
   * @return Result scaled by 1e18
   */
  function cos(uint256 _angle) internal pure returns (int256) {
    unchecked {
      return sin(_angle + PI_OVER_TWO);
    }
  }
}


contract EventLogger {
    struct LogEntry {
        address sender;
        string eventType;  // Lo·∫°i s·ª± ki·ªán (VD: "Deposit", "Withdraw", "Trade", "UpdateStatus")
        string details;    // M√¥ t·∫£ chi ti·∫øt s·ª± ki·ªán (VD: "User deposited 100 USDT")
        uint256 timestamp; // Th·ªùi gian x·∫£y ra s·ª± ki·ªán
    }

    mapping(uint256 => LogEntry) public logs;
    uint256 public logCount;
    address public owner;

    // S·ª± ki·ªán khi c√≥ log m·ªõi ho·∫∑c log b·ªã x√≥a
    event LogEvent(uint256 indexed logId, address indexed sender, string eventType, string details, uint256 timestamp);
    event LogDeleted(uint256 indexed logId);
    event LogsClearedBefore(uint256 timestamp);
    event LogsClearedUpTo(uint256 upToId);
    event LogsCleared();

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can perform this action");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    // Ghi l·∫°i m·ªôt log event quan tr·ªçng
    function recordEvent(string memory eventType, string memory details) external {
        logCount++;
        logs[logCount] = LogEntry(msg.sender, eventType, details, block.timestamp);
        emit LogEvent(logCount, msg.sender, eventType, details, block.timestamp);
    }

    // X√≥a m·ªôt event theo ID (ch·ªâ owner m·ªõi c√≥ th·ªÉ x√≥a)
    function deleteEvent(uint256 logId) external onlyOwner {
        require(logs[logId].timestamp != 0, "Log does not exist");
        delete logs[logId];
        emit LogDeleted(logId);
    }

    // X√≥a t·∫•t c·∫£ logs c√≥ timestamp **tr∆∞·ªõc** th·ªùi ƒëi·ªÉm `beforeTimestamp`
    function clearLogsBefore(uint256 beforeTimestamp) external onlyOwner {
        require(beforeTimestamp > 0 && beforeTimestamp <= block.timestamp, "Invalid timestamp");

        uint256 clearedLogs = 0;

        for (uint256 i = 1; i <= logCount; i++) {
            if (logs[i].timestamp > 0 && logs[i].timestamp < beforeTimestamp) {
                delete logs[i];
                clearedLogs++;
            }
        }

        emit LogsClearedBefore(beforeTimestamp);
    }

    // üÜï X√≥a t·∫•t c·∫£ logs c√≥ ID **‚â§ upToId**
    function clearLogsUpTo(uint256 upToId) external onlyOwner {
        require(upToId > 0 && upToId <= logCount, "Invalid ID range");

        uint256 clearedLogs = 0;

        for (uint256 i = 1; i <= upToId; i++) {
            if (logs[i].timestamp > 0) {
                delete logs[i];
                clearedLogs++;
            }
        }

        emit LogsClearedUpTo(upToId);
    }

    // X√≥a to√†n b·ªô logs (ch·ªâ owner c√≥ th·ªÉ th·ª±c hi·ªán)
    function clearLogs() external onlyOwner {
        for (uint256 i = 1; i <= logCount; i++) {
            delete logs[i];
        }
        logCount = 0;
        emit LogsCleared();
    }

    // L·∫•y th√¥ng tin m·ªôt log d·ª±a tr√™n ID
    function getLog(uint256 logId) external onlyOwner view returns (address sender, string memory eventType, string memory details, uint256 timestamp) {
        LogEntry memory log = logs[logId];
        require(log.timestamp != 0, "Log does not exist");
        return (log.sender, log.eventType, log.details, log.timestamp);
    }

    // L·∫•y t·ªïng s·ªë log ƒë√£ ghi l·∫°i
    function getTotalLogs() external onlyOwner view returns (uint256) {
        return logCount;
    }
}

interface ITreeCommission {
    /**
     * @dev R√∫t m·ªôt l∆∞·ª£ng BP t·ª´ t√†i kho·∫£n ng∆∞·ªùi d√πng.
     * @param amount S·ªë l∆∞·ª£ng BP c·∫ßn r√∫t.
     */
    function withdrawBP(uint256 amount) external;
    function withdrawBPToAnotherUser(uint256 amount, address user) external;
}

// BalancesManager: Qu·∫£n l√Ω s·ªë d∆∞, giao d·ªãch, r√∫t ti·ªÅn.
contract BalancesManager is Ownable {

    // ultraUTXO
    
    struct BPultraUTXO {
        uint256 BP;
        uint256 createTime;
        uint256 activeTime;
        uint256 expiredTime;
        bool isDeny;
    }


    mapping(bytes32 => address[]) public utxoToUsers;
    mapping(address => mapping(bytes32 => BPultraUTXO)) public userUltraBP;
    bytes32[] public allUltraUTXO; // ‚úÖ Danh s√°ch to√†n b·ªô UTXO


    mapping(address => uint256) public balances;


    struct NodeExtra {
        bytes32 refCode;
        string phoneNumber;
        string nickName;
        uint256 longtitude;
        uint256 lattitude;
    }

    mapping(address => NodeExtra) public nodeExtras;

    mapping(bytes32 => address) public allUserRefCodes;


    address public treeCommissionContract;


    uint256 internal nationalBonusPool;
    mapping(bytes32 => uint256) internal pendingNationalBonusPool; // L∆∞u BP ƒëang ch·ªù duy·ªát


    modifier onlyTreeCommission() {
        require(msg.sender == treeCommissionContract, "Unauthorized");
        _;
    }

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }

    constructor() Ownable(msg.sender) {}

    function setTreeCommissionAddress(address _treeCommissionAddress) external onlyOwner {
        treeCommissionContract = _treeCommissionAddress;
    }

    function isValidUTXO(bytes32 utxoID) internal pure returns (bool) {
        return utxoID != bytes32(0);
    }

    // ultra utxo

        // BP Ultra UTXO

    function createUltraUTXO(
        address user,
        bytes32 utxoID,
        uint256 amount
    ) internal {
        require(userUltraBP[user][utxoID].BP == 0, "UTXO already exists");

        uint256 createTime = block.timestamp;
        uint256 activeTime = createTime + 60 days;
        uint256 expiredTime = createTime + 180 days;

        userUltraBP[user][utxoID] = BPultraUTXO(amount, createTime, activeTime, expiredTime, false);
        utxoToUsers[utxoID].push(user);
        allUltraUTXO.push(utxoID); // ‚úÖ L∆∞u v√†o danh s√°ch to√†n c·ª•c
    }

    function cancelUltraUTXO(
        bytes32 utxoID
    ) internal {
        require(utxoToUsers[utxoID].length > 0, "UTXO does not exist");

        for (uint256 i = 0; i < utxoToUsers[utxoID].length; i++) {
            address user = utxoToUsers[utxoID][i];

            if (userUltraBP[user][utxoID].BP > 0) {
                userUltraBP[user][utxoID].isDeny = true;
            }
        }
    }

    function withdrawUltraBP(
        address user,
        bytes32 utxoID
    ) internal {
        BPultraUTXO storage ultra = userUltraBP[user][utxoID];

        require(ultra.BP > 0, "No UltraBP available");
        require(!ultra.isDeny, "UTXO has been canceled");
        require(block.timestamp >= ultra.activeTime, "UltraBP is not yet withdrawable");
        require(block.timestamp <= ultra.expiredTime, "UltraBP has expired");

        uint256 amount = ultra.BP;
        require(amount > 0, "withdraw: Wrong amount");

        delete userUltraBP[user][utxoID];

        // g·ªçi ƒë·∫øn SM ultraUTXO

        // usdtToken.transfer(user, amount);
    }

    function getUltraBPInfo(address user, bytes32 utxoID)
        external
        view
        returns (uint256 BP, uint256 createTime, uint256 activeTime, uint256 expiredTime, bool isDeny)
    {
        BPultraUTXO memory ultra = userUltraBP[user][utxoID];
        return (ultra.BP, ultra.createTime, ultra.activeTime, ultra.expiredTime, ultra.isDeny);
    }

    function getAllUltraUTXOs() external view returns (bytes32[] memory) {
        return allUltraUTXO;
    }

    function getUserUltraUTXOs(address user) external view returns (bytes32[] memory) {
        bytes32[] memory userUTXOs = new bytes32[](allUltraUTXO.length);
        uint256 count = 0;

        for (uint256 i = 0; i < allUltraUTXO.length; i++) {
            if (userUltraBP[user][allUltraUTXO[i]].BP > 0) {
                userUTXOs[count] = allUltraUTXO[i];
                count++;
            }
        }

        bytes32[] memory trimmed = new bytes32[](count);
        for (uint256 i = 0; i < count; i++) {
            trimmed[i] = userUTXOs[i];
        }

        return trimmed;
    }


    function updateBalance(address user, bytes32 utxoID, uint256 amount, bool isAdd) external onlyTreeCommission {
        require(amount > 0, "update balance: Wrong amount");
        if (isAdd) {
            if (isValidUTXO(utxoID)) {
              balances[user] += amount;
            } else {
              createUltraUTXO(user, utxoID, amount);
            }
        } else {
            require(balances[user] >= amount, "Insufficient balance");
            balances[user] -= amount;
        }
    }

    function batchUpdateBalances(bytes32 utxoID, address[] calldata users, uint256[] calldata amounts, bool isAdd) external onlyTreeCommission {
        require(users.length == amounts.length, "Array lengths mismatch");
        for (uint256 i = 0; i < users.length; i++) {
            require(amounts[i] > 0, "update balance: Wrong amount");
            if (isAdd) {
                if (isValidUTXO(utxoID)) {
                  balances[users[i]] += amounts[i];
                } else {
                  createUltraUTXO(users[i], utxoID, amounts[i]);
                }
            } else {
                require(balances[users[i]] >= amounts[i], "Insufficient balance for user");
                balances[users[i]] -= amounts[i];
            }
        }
    }

    function getBalance(address user) external view returns (uint256) {
        return balances[user];
    }

    function withdrawBP(address user, uint256 amount) external onlyTreeCommission returns (bool) {
        if(amount <= 0) {
          return false;
        }
        if(balances[user] < amount) {
          return false;
        }

        balances[msg.sender] -= amount;

        return true;
    }

    function getRefCode() external view onlyEOA returns (bytes32) {
        // require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng

        return nodeExtras[msg.sender].refCode;
    }


    function getRefCodeToUser(bytes32 refCode) external view onlyEOA returns (address) {
        // require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng

        return allUserRefCodes[refCode];
    }


    function setRefCodeToUser(bytes32 oldRefCode, bytes32 newRefCode) external onlyEOA  {
        // require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng
        require(newRefCode != bytes32(0), "refCode not allowed");
        require( allUserRefCodes[oldRefCode] == msg.sender , "ref code not exists" );
        require( nodeExtras[msg.sender].refCode == oldRefCode , "ref code not exists in user" );

        require( allUserRefCodes[oldRefCode] == allUserRefCodes[newRefCode] , "ref code not match" );
        
        require( allUserRefCodes[newRefCode] != address(0) , "ref code exists in another user" );
        
        delete allUserRefCodes[oldRefCode];
        allUserRefCodes[newRefCode] = msg.sender;

        nodeExtras[msg.sender].refCode = newRefCode;
    }

    function setPhoneNumber(string calldata phoneNumber) external onlyEOA {
        // require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng

        require(bytes(phoneNumber).length > 0, "Phone number not allowed"); // Ki·ªÉm tra phone number kh√¥ng r·ªóng

        // require(nodes[msg.sender].parent != address(0), "User does not exist"); // Ki·ªÉm tra t√†i kho·∫£n t·ªìn t·∫°i kh√¥ng
        // require(block.timestamp <= nodeData[msg.sender].membershipExpiry, "Membership expired, cannot renew"); // Ki·ªÉm tra h·∫°n

        nodeExtras[msg.sender].phoneNumber = phoneNumber;
    }

    function setNickName(string calldata nickName) external onlyEOA {
        // require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng

        require(bytes(nickName).length > 0, "nickName not allow"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng

        // require(nodes[msg.sender].parent != address(0), "User does not exist"); // Ki·ªÉm tra t√†i kho·∫£n t·ªìn t·∫°i kh√¥ng
        // require(block.timestamp <= nodeData[msg.sender].membershipExpiry, "Membership expired, cannot renew"); // Ki·ªÉm tra h·∫°n

        nodeExtras[msg.sender].nickName = nickName;
    }

    function initUser(address user, uint256 longtitude, uint256 lattitude) external onlyTreeCommission {
        // require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng

        require(longtitude > 0, "longtitude not allow");
        require(lattitude > 0, "longtitude not allow");

        // require(nodes[msg.sender].parent != address(0), "User does not exist"); // Ki·ªÉm tra t√†i kho·∫£n t·ªìn t·∫°i kh√¥ng
        // require(block.timestamp <= nodeData[msg.sender].membershipExpiry, "Membership expired, cannot renew"); // Ki·ªÉm tra h·∫°n


        bytes32 refCode = keccak256(abi.encodePacked(user));

        require( allUserRefCodes[refCode] != address(0) , "ref code exists in another user" );
        
        allUserRefCodes[refCode] = user;

        nodeExtras[user] = NodeExtra({
            refCode: refCode,
            longtitude: longtitude,
            lattitude: lattitude,
            phoneNumber: "",
            nickName: ""
        });
    }

    // c·ªông balance cho bonus
    function addNationalBonusPool(uint256 amount, bytes32 utxoID) external {
      if (isValidUTXO(utxoID)) {
        pendingNationalBonusPool[utxoID] += amount;
      } else {
        nationalBonusPool += amount;
      }
    }
    function getNationalBonusPool() external view returns (uint256) {
      return nationalBonusPool;
    }
    function getPendingNationalBonusPool(bytes32 utxoID) external view returns (uint256) {
      return pendingNationalBonusPool[utxoID];
    }
    function resetNationalBonusPool(uint256 currentAmount) external {
      require(nationalBonusPool == currentAmount, "not match");
      nationalBonusPool = 0;
    }

    

    function confirmUTXO(bytes32 utxoID) external onlyOwner {
        require(pendingNationalBonusPool[utxoID] > 0, "not exists");
        nationalBonusPool += pendingNationalBonusPool[utxoID];
        delete pendingNationalBonusPool[utxoID]; // X√≥a d·ªØ li·ªáu sau khi chuy·ªÉn v√†o pool ch√≠nh
    }
}


/**
 * @title DAO Voting Contract
 * @dev Qu·∫£n l√Ω bi·ªÉu quy·∫øt chi ti√™u. Y√™u c·∫ßu 2/3 phi·∫øu ch·∫•p thu·∫≠n.
 */
contract ProposalVote {
    struct Proposal {
        address payable recipient; 
        uint256 amount;            
        string reason;             
        uint256 approvals;         
        uint256 rejections;        
        bool executed;             
    }

    struct MembershipProposal {
        address member;
        uint256 approvals;
        uint256 rejections;
        bool executed;
    }

    address[] public members; 
    mapping(address => bool) public isMember; 
    mapping(uint256 => Proposal) public proposals; 
    mapping(uint256 => MembershipProposal) public membershipProposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted;
    mapping(uint256 => mapping(address => bool)) public hasVotedMembership;
    
    uint256 public proposalCount;
    uint256 public membershipProposalCount;

    uint256 public approvalPercentage = 70;

    BalancesManager public balancesManager;
    address public treeCommissionContract;

    modifier onlyMember() {
        require(isMember[msg.sender], "Not a DAO member");
        _;
    }

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }
        
    constructor(address[] memory _initialMembers, address _balancesAddress) {
        require(_initialMembers.length >= 3, "Must have at least 3 members");
        for (uint i = 0; i < _initialMembers.length; i++) {
            isMember[_initialMembers[i]] = true;
            members.push(_initialMembers[i]);
        }

        balancesManager = BalancesManager(_balancesAddress);
        treeCommissionContract = msg.sender;
    }

    /**
     * @dev Y√™u c·∫ßu th√™m m·ªôt th√†nh vi√™n m·ªõi th√¥ng qua bi·ªÉu quy·∫øt
     * @param _newMember ƒê·ªãa ch·ªâ c·ªßa th√†nh vi√™n m·ªõi
     */
    function proposeAddMember(address _newMember) external onlyEOA onlyMember {
        require(!isMember[_newMember], "Already a member");

        membershipProposals[membershipProposalCount] = MembershipProposal({
            member: _newMember,
            approvals: 0,
            rejections: 0,
            executed: false
        });

        emit MemberProposalCreated(membershipProposalCount, _newMember);
        membershipProposalCount++;
    }

    /**
     * @dev Bi·ªÉu quy·∫øt th√™m th√†nh vi√™n m·ªõi
     * @param _proposalId ID c·ªßa ƒë·ªÅ xu·∫•t
     * @param _approve ƒê·ªìng √Ω hay t·ª´ ch·ªëi (true = ƒë·ªìng √Ω, false = t·ª´ ch·ªëi)
     */
    function voteToAddMember(uint256 _proposalId, bool _approve) external onlyEOA onlyMember {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(!proposal.executed, "Proposal already executed");
        require(!hasVotedMembership[_proposalId][msg.sender], "Already voted");

        hasVotedMembership[_proposalId][msg.sender] = true;

        if (_approve) {
            proposal.approvals++;
        } else {
            proposal.rejections++;
        }

        emit VotedMembership(_proposalId, msg.sender, _approve);

        if (proposal.approvals >= getApprovalThreshold()) {
            executeAddMember(_proposalId);
        }
    }

    /**
     * @dev Th·ª±c thi th√™m th√†nh vi√™n m·ªõi n·∫øu ƒë·ªß phi·∫øu
     */
    function executeAddMember(uint256 _proposalId) internal {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(proposal.approvals >= getApprovalThreshold(), "Not enough approvals");
        require(!proposal.executed, "Proposal already executed");

        proposal.executed = true;
        isMember[proposal.member] = true;
        members.push(proposal.member);

        emit MemberAdded(proposal.member);
    }

    /**
     * @dev Y√™u c·∫ßu lo·∫°i b·ªè m·ªôt th√†nh vi√™n th√¥ng qua bi·ªÉu quy·∫øt
     * @param _member ƒê·ªãa ch·ªâ c·ªßa th√†nh vi√™n b·ªã lo·∫°i b·ªè
     */
    function proposeRemoveMember(address _member) external onlyEOA onlyMember {
        require(isMember[_member], "Not a member");

        membershipProposals[membershipProposalCount] = MembershipProposal({
            member: _member,
            approvals: 0,
            rejections: 0,
            executed: false
        });

        emit MemberProposalCreated(membershipProposalCount, _member);
        membershipProposalCount++;
    }

    /**
     * @dev Bi·ªÉu quy·∫øt lo·∫°i b·ªè th√†nh vi√™n
     * @param _proposalId ID c·ªßa ƒë·ªÅ xu·∫•t
     * @param _approve ƒê·ªìng √Ω hay t·ª´ ch·ªëi (true = ƒë·ªìng √Ω, false = t·ª´ ch·ªëi)
     */
    function voteToRemoveMember(uint256 _proposalId, bool _approve) external onlyEOA onlyMember {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(!proposal.executed, "Proposal already executed");
        require(!hasVotedMembership[_proposalId][msg.sender], "Already voted");

        hasVotedMembership[_proposalId][msg.sender] = true;

        if (_approve) {
            proposal.approvals++;
        } else {
            proposal.rejections++;
        }

        emit VotedMembership(_proposalId, msg.sender, _approve);

        if (proposal.approvals >= getApprovalThreshold()) {
            executeRemoveMember(_proposalId);
        }
    }

    /**
     * @dev Th·ª±c thi lo·∫°i b·ªè th√†nh vi√™n n·∫øu ƒë·ªß phi·∫øu
     */
    function executeRemoveMember(uint256 _proposalId) internal {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(proposal.approvals >= getApprovalThreshold(), "Not enough approvals");
        require(!proposal.executed, "Proposal already executed");

        proposal.executed = true;
        isMember[proposal.member] = false;

        for (uint i = 0; i < members.length; i++) {
            if (members[i] == proposal.member) {
                members[i] = members[members.length - 1];
                members.pop();
                break;
            }
        }

        emit MemberRemoved(proposal.member);
    }

    /**
     * @dev T√≠nh s·ªë phi·∫øu c·∫ßn thi·∫øt ƒë·ªÉ ph√™ duy·ªát ƒë·ªÅ xu·∫•t
     */
    function getApprovalThreshold() public view returns (uint256) {
        return (members.length * approvalPercentage) / 100;
    }

    event MemberProposalCreated(uint256 indexed proposalId, address indexed member);
    event MemberAdded(address indexed newMember);
    event MemberRemoved(address indexed removedMember);
    event VotedMembership(uint256 indexed proposalId, address indexed voter, bool approve);

    /**
     * @dev T·∫°o m·ªôt ƒë·ªÅ xu·∫•t chi ti√™u m·ªõi
     * @param _recipient ƒê·ªãa ch·ªâ v√≠ nh·∫≠n ti·ªÅn
     * @param _amount S·ªë ti·ªÅn mu·ªën chi
     * @param _reason L√Ω do chi ti√™u
     */
    function createProposal(address payable _recipient, uint256 _amount, string memory _reason) 
        external onlyEOA onlyMember 
    {
        proposals[proposalCount] = Proposal({
            recipient: _recipient,
            amount: _amount,
            reason: _reason,
            approvals: 0,
            rejections: 0,
            executed: false
        });

        emit ProposalCreated(proposalCount, _recipient, _amount, _reason, msg.sender);
        proposalCount++;
    }

    /**
     * @dev Bi·ªÉu quy·∫øt m·ªôt ƒë·ªÅ xu·∫•t
     * @param _proposalId ID c·ªßa ƒë·ªÅ xu·∫•t
     * @param _approve ƒê·ªìng √Ω hay t·ª´ ch·ªëi (true = ƒë·ªìng √Ω, false = t·ª´ ch·ªëi)
     */
    function voteProposal(uint256 _proposalId, bool _approve) external onlyEOA onlyMember {
        Proposal storage proposal = proposals[_proposalId];

        require(!proposal.executed, "Proposal already executed");
        require(!hasVoted[_proposalId][msg.sender], "Already voted");

        hasVoted[_proposalId][msg.sender] = true;

        if (_approve) {
            proposal.approvals++;
        } else {
            proposal.rejections++;
        }

        emit Voted(_proposalId, msg.sender, _approve);

        // Ki·ªÉm tra n·∫øu c√≥ ƒë·ªß 2/3 s·ªë phi·∫øu ƒë·ªìng √Ω, th·ª±c thi ƒë·ªÅ xu·∫•t
        if (proposal.approvals >= getApprovalThreshold()) {
            executeProposal(_proposalId);
        }
    }

    /**
     * @dev Th·ª±c thi ƒë·ªÅ xu·∫•t ƒë√£ ƒë∆∞·ª£c duy·ªát
     * @param _proposalId ID c·ªßa ƒë·ªÅ xu·∫•t
     */
    function executeProposal(uint256 _proposalId) internal {
        Proposal storage proposal = proposals[_proposalId];

        require(proposal.approvals >= getApprovalThreshold(), "Not enough approvals");
        require(!proposal.executed, "Proposal already executed");

        proposal.executed = true;

        uint256 amount = proposal.amount;

        ITreeCommission treeCommission = ITreeCommission(treeCommissionContract);
        treeCommission.withdrawBPToAnotherUser(amount, proposal.recipient);

    }

    /**
     * @dev Ki·ªÉm tra s·ªë d∆∞ hi·ªán t·∫°i c·ªßa DAO
     */
    function getBalance() external view onlyEOA returns (uint256) {
        return balancesManager.getBalance(msg.sender);
    }

    /**
     * @dev L·∫•y th√¥ng tin chi ti·∫øt c·ªßa m·ªôt ƒë·ªÅ xu·∫•t
     * @param _proposalId ID c·ªßa ƒë·ªÅ xu·∫•t
     */
    function getProposal(uint256 _proposalId) external view onlyEOA returns (
        address recipient, uint256 amount, string memory reason, uint256 approvals, uint256 rejections, bool executed
    ) {
        Proposal storage proposal = proposals[_proposalId];
        return (proposal.recipient, proposal.amount, proposal.reason, proposal.approvals, proposal.rejections, proposal.executed);
    }

    /**
     * @dev S·ª± ki·ªán khi t·∫°o ƒë·ªÅ xu·∫•t m·ªõi
     */
    event ProposalCreated(uint256 indexed proposalId, address indexed recipient, uint256 amount, string reason, address indexed creator);

    /**
     * @dev S·ª± ki·ªán khi c√≥ th√†nh vi√™n bi·ªÉu quy·∫øt
     */
    event Voted(uint256 indexed proposalId, address indexed voter, bool approve);

    /**
     * @dev S·ª± ki·ªán khi m·ªôt ƒë·ªÅ xu·∫•t ƒë∆∞·ª£c th·ª±c thi th√†nh c√¥ng
     */
    event ProposalExecuted(uint256 indexed proposalId, address indexed recipient, uint256 amount);
}

/**
 * @title eStock
 * @dev H·ª£p ƒë·ªìng ERC20 m·ªü r·ªông ƒë·ªÉ qu·∫£n l√Ω c·ªï phi·∫øu s·ªë (eStock) mua b·∫±ng USDT.
 * Ch·ª©c nƒÉng ch√≠nh:
 * 1. Mua eStock b·∫±ng USDT theo t·ª∑ gi√° do admin qu·∫£n l√Ω.
 * 2. Nh·∫≠n l·ª£i nhu·∫≠n t·ª´ c√°c h·ª£p ƒë·ªìng kh√°c b·∫±ng USDT.
 * 3. R√∫t hoa h·ªìng USDT ƒë√£ t√≠ch l≈©y.
 * 4. Qu·∫£n l√Ω t·ª∑ gi√° v√† theo d√µi th√¥ng tin giao d·ªãch c·ªßa user.
 */
contract eStock is ERC20, Ownable {
    IERC20 public usdtToken; // ƒê·ªãa ch·ªâ h·ª£p ƒë·ªìng USDT

    uint256 public exchangeRate; // T·ª∑ gi√° eStock/USDT (l∆∞u v·ªõi 6 ch·ªØ s·ªë th·∫≠p ph√¢n)
    uint256 public totalUSDTReceived; // T·ªïng USDT ƒë√£ nh·∫≠n t·ª´ c√°c ngu·ªìn kh√°c
    uint256 public totalUSDTWithdrawn; // T·ªïng USDT ƒë√£ r√∫t

    mapping(address => uint256) public userUSDTBalance; // S·ªë d∆∞ USDT c·ªßa user
    mapping(address => uint256) public userUSDTWithdrawn; // T·ªïng USDT user ƒë√£ r√∫t

    // S·ª± ki·ªán
    event ExchangeRateUpdated(uint256 newRate);
    event StockPurchased(address indexed buyer, uint256 amount, uint256 usdtSpent);
    event ProfitReceived(address indexed source, uint256 amount);
    event USDTWithdrawn(address indexed user, uint256 amount);


    address public treeCommissionContract;
    /**
     * @dev Kh·ªüi t·∫°o h·ª£p ƒë·ªìng eStock.
     * @param name T√™n token
     * @param symbol K√Ω hi·ªáu token
     * @param initialSupply T·ªïng s·ªë token ban ƒë·∫ßu
     * @param _exchangeRate T·ª∑ gi√° eStock/USDT ban ƒë·∫ßu
     * @param _usdtAddress ƒê·ªãa ch·ªâ h·ª£p ƒë·ªìng USDT
     */
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply,
        uint256 _exchangeRate,
        address _usdtAddress
    ) ERC20(name, symbol) Ownable(msg.sender) {
        _mint(msg.sender, initialSupply * (10 ** decimals())); // Ph√°t h√†nh token ban ƒë·∫ßu
        exchangeRate = _exchangeRate;


        // G√°n ƒë·ªãa ch·ªâ h·ª£p ƒë·ªìng USDT cho bi·∫øn usdtToken
        usdtToken = IERC20(_usdtAddress);
        
        treeCommissionContract = msg.sender;
    }

    /**
     * @dev C·∫≠p nh·∫≠t t·ª∑ gi√° quy ƒë·ªïi eStock/USDT (ch·ªâ Owner c√≥ th·ªÉ thay ƒë·ªïi).
     * @param newRate T·ª∑ gi√° m·ªõi.
     */
    function setExchangeRate(uint256 newRate) external onlyOwner {
        require(newRate > 0, "Rate must be greater than 0");
        exchangeRate = newRate;
        emit ExchangeRateUpdated(newRate);
    }

    /**
     * @dev Tr·∫£ v·ªÅ t·ª∑ gi√° hi·ªán t·∫°i c·ªßa eStock.
     */
    function getExchangeRate() external view returns (uint256) {
        return exchangeRate;
    }

    /**
     * @dev Ng∆∞·ªùi d√πng mua eStock b·∫±ng USDT.
     * @param usdtAmount S·ªë USDT g·ª≠i v√†o.
     * @param expectedRate T·ª∑ gi√° mong ƒë·ª£i ƒë·ªÉ tr√°nh thay ƒë·ªïi ƒë·ªôt ng·ªôt.
     */
    function buyStock(uint256 usdtAmount, uint256 expectedRate) external {
        require(usdtAmount > 0, "Must send USDT to buy stock");
        require(expectedRate == exchangeRate, "Exchange rate changed");
        
        uint256 stockAmount = (usdtAmount * exchangeRate) / 1e6;
        require(balanceOf(owner()) >= stockAmount, "Not enough stock available");
        
        uint256 balanceBefore = usdtToken.balanceOf(address(this));
        require(usdtToken.transferFrom(msg.sender, address(this), usdtAmount), "USDT transfer failed");
        uint256 balanceAfter = usdtToken.balanceOf(address(this));
        uint256 receivedUSDT = balanceAfter - balanceBefore;
        require(receivedUSDT >= usdtAmount - 1e6 && receivedUSDT <= usdtAmount + 1e6, "Incorrect USDT transfer amount");
        
        _transfer(owner(), msg.sender, stockAmount);
        emit StockPurchased(msg.sender, stockAmount, usdtAmount);
    }

    /**
     * @dev Nh·∫≠n l·ª£i nhu·∫≠n t·ª´ smart contract kh√°c b·∫±ng USDT.
     * @param amount S·ªë USDT nh·∫≠n ƒë∆∞·ª£c.
     */
    function receiveProfitFromContract(uint256 amount) external {
        require(amount > 0, "Amount must be greater than 0");
        require(usdtToken.transferFrom(msg.sender, address(this), amount), "USDT transfer failed");
        totalUSDTReceived += amount;
        userUSDTBalance[msg.sender] += amount;
        emit ProfitReceived(msg.sender, amount);
    }

    /**
     * @dev User r√∫t USDT t·ª´ s·ªë d∆∞ l·ª£i nhu·∫≠n.
     */
    function withdrawUSDTCommission() external {
        uint256 amount = userUSDTBalance[msg.sender];
        require(amount > 0, "No USDT balance to withdraw");
        userUSDTBalance[msg.sender] = 0;
        userUSDTWithdrawn[msg.sender] += amount;
        totalUSDTWithdrawn += amount;
        // require(usdtToken.transfer(msg.sender, amount), "USDT transfer failed");

        ITreeCommission treeCommission = ITreeCommission(treeCommissionContract);
        treeCommission.withdrawBPToAnotherUser(amount, msg.sender);

        emit USDTWithdrawn(msg.sender, amount);
    }

    /**
     * @dev Xem s·ªë d∆∞ eStock c·ªßa user.
     */
    function getUserStockBalance(address user) external view returns (uint256) {
        return balanceOf(user);
    }

    /**
     * @dev Xem s·ªë d∆∞ hoa h·ªìng USDT c·ªßa user.
     */
    function getUserUSDTCommission(address user) external view returns (uint256) {
        return userUSDTBalance[user];
    }

    /**
     * @dev Xem t·ªïng USDT user ƒë√£ r√∫t.
     */
    function getUserUSDTWithdrawn(address user) external view returns (uint256) {
        return userUSDTWithdrawn[user];
    }

    /**
     * @dev Xem t·ªïng USDT ƒë√£ nh·∫≠n v√†o h·ª£p ƒë·ªìng t·ª´ c√°c ngu·ªìn kh√°c.
     */
    function getTotalUSDTReceived() external view returns (uint256) {
        return totalUSDTReceived;
    }

    /**
     * @dev Xem t·ªïng USDT ƒë√£ r√∫t kh·ªèi h·ª£p ƒë·ªìng.
     */
    function getTotalUSDTWithdrawn() external view returns (uint256) {
        return totalUSDTWithdrawn;
    }
}

contract Showroom is Ownable {
    
    /**
     * @dev Enum ƒë·ªãnh nghƒ©a c√°c c·∫•p b·∫≠c c·ªßa showroom
     */
    enum ShowroomTier {
        InActive,  // Ch∆∞a k√≠ch ho·∫°t
        ShopInShop, // Qu·∫ßy ƒë·∫∑t t·∫°i c·ª≠a h√†ng c·ªßa ng∆∞·ªùi kh√°c
        Kiosk,     // Qu·∫ßy nh·ªè
        Retail,    // C·ª≠a h√†ng
        Hub        // Trung t√¢m l·ªõn
    }

    // Mapping l∆∞u t·ª∑ l·ªá hoa h·ªìng cho showroom theo t·ª´ng c·∫•p
    mapping(ShowroomTier => uint256) public showroomCommissionRates;
    // Mapping l∆∞u b√°n k√≠nh qu√©t showroom theo t·ª´ng c·∫•p (m√©t)
    mapping(ShowroomTier => uint256) public scanRadius;
    // Mapping l∆∞u b√°n k√≠nh an to√†n cho showroom (m√©t)
    mapping(ShowroomTier => uint256) public safeRadius;

    /**
     * @dev Struct ƒë·∫°i di·ªán cho showroom
     */
    struct ShowroomNode {
        address parent;         // Showroom cha
        ShowroomTier tier;      // C·∫•p b·∫≠c showroom
        uint256 totalBP;        // T·ªïng BP c·ªßa showroom
        uint256 totalMember;    // T·ªïng th√†nh vi√™n thu·ªôc showroom
        uint256 expiryDate;     // Th·ªùi gian h·∫øt h·∫°n showroom
        uint256 longtitude;     // Kinh ƒë·ªô showroom
        uint256 lattitude;      // Vƒ© ƒë·ªô showroom
    }

    // Danh s√°ch showroom v√† mapping l∆∞u th√¥ng tin showroom
    address[] public allShowrooms;
    mapping(address => ShowroomNode) public showroomNodes;

    event ShowroomAdded(address indexed showroom, address indexed parent);

    address public treeCommissionContract;

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }

    constructor() Ownable(msg.sender) {
        
        // Kh·ªüi t·∫°o t·ª∑ l·ªá hoa h·ªìng cho showroom theo t·ª´ng c·∫•p
        showroomCommissionRates[ShowroomTier.ShopInShop] = 25;      // 25% cho qu·∫ßy nh·ªè
        showroomCommissionRates[ShowroomTier.Kiosk] = 50;      // 25% cho qu·∫ßy nh·ªè
        showroomCommissionRates[ShowroomTier.Retail] = 75;     // 50% cho c·ª≠a h√†ng v·ª´a
        showroomCommissionRates[ShowroomTier.Hub] = 100;       // 100% cho trung t√¢m l·ªõn

        // C√†i ƒë·∫∑t b√°n k√≠nh qu√©t showroom (m√©t)
        scanRadius[ShowroomTier.ShopInShop] = 50;       // 50m
        scanRadius[ShowroomTier.Kiosk] = 500;       // 500m
        scanRadius[ShowroomTier.Retail] = 2000;     // 2km
        scanRadius[ShowroomTier.Hub] = 5000;        // 5km

        // C√†i ƒë·∫∑t b√°n k√≠nh an to√†n (m√©t) ƒë·ªÉ showroom nh·∫≠n hoa h·ªìng khi user g·∫ßn
        safeRadius[ShowroomTier.ShopInShop] = 50;        // 50m
        safeRadius[ShowroomTier.Kiosk] = 50;        // 50m
        safeRadius[ShowroomTier.Retail] = 100;       // 100m
        safeRadius[ShowroomTier.Hub] = 500;         // 500m
    }
    
    modifier onlyTreeCommission() {
        require(msg.sender == treeCommissionContract, "Not authorized");
        _;
    }

    function setTreeCommissionContract(address _treeCommission) external onlyOwner {
        treeCommissionContract = _treeCommission;
    }

    /**
     * @dev C·∫≠p nh·∫≠t t·ª∑ l·ªá hoa h·ªìng showroom theo c·∫•p b·∫≠c
     * @param tier C·∫•p b·∫≠c showroom
     * @param percent Ph·∫ßn trƒÉm hoa h·ªìng m·ªõi
     */
    function setShowroomCommissionRate(ShowroomTier tier, uint256 percent) public onlyOwner {
        showroomCommissionRates[tier] = percent;
    }

    /**
     * @dev C·∫≠p nh·∫≠t b√°n k√≠nh qu√©t showroom
     * @param tier C·∫•p b·∫≠c showroom
     * @param radius B√°n k√≠nh m·ªõi (m√©t)
     */
    function setShowroomScanRadius(ShowroomTier tier, uint256 radius) public onlyOwner {
        scanRadius[tier] = radius;
    }

    /**
     * @dev C·∫≠p nh·∫≠t b√°n k√≠nh an to√†n cho showroom
     * @param tier C·∫•p b·∫≠c showroom
     * @param radius B√°n k√≠nh an to√†n m·ªõi (m√©t)
     */
    function setShowroomSafeRadius(ShowroomTier tier, uint256 radius) public onlyOwner {
        safeRadius[tier] = radius;
    }

    /**
     * @dev Thi·∫øt l·∫≠p ng√†y h·∫øt h·∫°n m·ªõi cho showroom
     * @param showroom ƒê·ªãa ch·ªâ showroom
     * @param changedDays S·ªë ng√†y thay ƒë·ªïi (c·ªông th√™m ho·∫∑c gi·∫£m)
     */
    function setShowroomExpiryDate(address showroom, uint256 changedDays) public onlyOwner {
        showroomNodes[showroom].expiryDate = block.timestamp + (changedDays * 1 days);
    }

    /**
     * @dev L·∫•y t·ª∑ l·ªá hoa h·ªìng c·ªßa m·ªôt showroom theo c·∫•p b·∫≠c
     * @param tier C·∫•p b·∫≠c showroom
     * @return Ph·∫ßn trƒÉm hoa h·ªìng hi·ªán t·∫°i
     */
    function getShowroomCommissionRate(ShowroomTier tier) public view returns (uint256) {
        return showroomCommissionRates[tier];
    }

    /**
     * @dev L·∫•y b√°n k√≠nh qu√©t showroom hi·ªán t·∫°i
     * @param tier C·∫•p b·∫≠c showroom
     * @return B√°n k√≠nh qu√©t (m√©t)
     */
    function getShowroomScanRadius(ShowroomTier tier) public view returns (uint256) {
        return scanRadius[tier];
    }

    /**
     * @dev L·∫•y b√°n k√≠nh an to√†n showroom hi·ªán t·∫°i
     * @param tier C·∫•p b·∫≠c showroom
     * @return B√°n k√≠nh an to√†n (m√©t)
     */
    function getShowroomSafeRadius(ShowroomTier tier) public view returns (uint256) {
        return safeRadius[tier];
    }

    /**
     * @dev Th√™m showroom m·ªõi v√†o h·ªá th·ªëng
     * @param newShowroom ƒê·ªãa ch·ªâ showroom m·ªõi
     * @param parent ƒê·ªãa ch·ªâ showroom cha
     * @param tier C·∫•p b·∫≠c showroom
     * @param longtitude Kinh ƒë·ªô c·ªßa showroom
     * @param lattitude Vƒ© ƒë·ªô c·ªßa showroom
     */
    function addShowRoom(address newShowroom, address parent, ShowroomTier tier, uint256 longtitude, uint256 lattitude) public onlyOwner {
        require(showroomNodes[newShowroom].parent == address(0), "Showroom already exists");

        // Kh·ªüi t·∫°o showroom m·ªõi v·ªõi d·ªØ li·ªáu ƒë·∫ßu v√†o
        showroomNodes[newShowroom] = ShowroomNode({
            parent: parent,
            tier: tier,
            totalBP: 0,
            totalMember: 0,
            expiryDate: block.timestamp + 365 days, // H·∫øt h·∫°n sau 12 th√°ng
            longtitude: longtitude,
            lattitude: lattitude
        });

        // Th√™m showroom m·ªõi v√†o danh s√°ch t·∫•t c·∫£ showroom
        allShowrooms.push(newShowroom);
    }

        /**
     * @dev L·∫•y danh s√°ch showroom theo ph√¢n trang
     * @param startIndex V·ªã tr√≠ b·∫Øt ƒë·∫ßu trong danh s√°ch showroom
     * @param pageSize S·ªë l∆∞·ª£ng showroom tr·∫£ v·ªÅ trong m·ªôt l·∫ßn
     * @return M·∫£ng c√°c ƒë·ªãa ch·ªâ showroom t·ª´ v·ªã tr√≠ startIndex v·ªõi ƒë·ªô d√†i pageSize
     */
    function getShowrooms(uint256 startIndex, uint256 pageSize) external view returns (ShowroomNode[] memory) {
        require(pageSize > 0 && pageSize <= 50, "pageSize must be between 1 and 50"); // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc trang ƒë·ªÉ tr√°nh qu√° t·∫£i

        uint256 totalChildCount = allShowrooms.length; // T·ªïng s·ªë showroom trong h·ªá th·ªëng

        if (startIndex >= totalChildCount) {
            return new ShowroomNode[](0);// Tr·∫£ v·ªÅ m·∫£ng r·ªóng n·∫øu startIndex v∆∞·ª£t qu√° t·ªïng s·ªë showroom
        }

        // X√°c ƒë·ªãnh ch·ªâ s·ªë k·∫øt th√∫c ƒë·ªÉ c·∫Øt m·∫£ng
        uint256 endIndex = startIndex + pageSize;
        if (endIndex > totalChildCount) {
            endIndex = totalChildCount; // N·∫øu endIndex l·ªõn h∆°n t·ªïng showroom, ƒë·∫∑t l·∫°i l√† t·ªïng showroom
        }

        ShowroomNode[] memory paginatedChildren = new ShowroomNode[](endIndex - startIndex); // M·∫£ng k·∫øt qu·∫£ c√≥ k√≠ch th∆∞·ªõc ch√≠nh x√°c
        uint256 resultIndex = 0;

        for (uint256 i = startIndex; i < endIndex; i++) {
            paginatedChildren[resultIndex] = showroomNodes[allShowrooms[i]]; // Th√™m showroom v√†o m·∫£ng k·∫øt qu·∫£
            resultIndex++;
        }

        return paginatedChildren; // Tr·∫£ v·ªÅ m·∫£ng showroom ƒë√£ ph√¢n trang
    }

    function abs(int256 x) internal pure returns (uint256) {
        return x < 0 ? uint256(-x) : uint256(x);
    }


    /**
     * @dev T√≠nh kho·∫£ng c√°ch gi·ªØa hai ƒëi·ªÉm ƒë·ªãa l√Ω b·∫±ng c√¥ng th·ª©c Haversine
     * @param lat1 Vƒ© ƒë·ªô ƒëi·ªÉm 1
     * @param lon1 Kinh ƒë·ªô ƒëi·ªÉm 1
     * @param lat2 Vƒ© ƒë·ªô ƒëi·ªÉm 2
     * @param lon2 Kinh ƒë·ªô ƒëi·ªÉm 2
     * @return Kho·∫£ng c√°ch t√≠nh b·∫±ng m√©t
     */
    function calculateDistance(
        uint256 lat1,
        uint256 lon1,
        uint256 lat2,
        uint256 lon2
    ) public pure returns (uint256) {
        int256 R = 6371000 * 1e18; // B√°n k√≠nh Tr√°i ƒê·∫•t (m√©t)

        // L·∫•y gi√° tr·ªã tuy·ªát ƒë·ªëi ƒë·ªÉ tr√°nh overflow
        uint256 dLat = abs(int256(lat2) - int256(lat1)) * Trigonometry.PI / (180 * 1e18);
        uint256 dLon = abs(int256(lon2) - int256(lon1)) * Trigonometry.PI / (180 * 1e18);

        uint256 lat1Rad = uint256(int256(lat1)) * Trigonometry.PI / (180 * 1e18);
        uint256 lat2Rad = uint256(int256(lat2)) * Trigonometry.PI / (180 * 1e18);

        int256 sinDLat = Trigonometry.sin(dLat / 2);
        int256 sinDLon = Trigonometry.sin(dLon / 2);
        int256 cosLat1 = Trigonometry.cos(lat1Rad);
        int256 cosLat2 = Trigonometry.cos(lat2Rad);

        int256 a = (sinDLat * sinDLat) + (cosLat1 * cosLat2 * (sinDLon * sinDLon));
        int256 c = 2 * Trigonometry.sin(uint256(a / 2)); // ƒê·∫£m b·∫£o ƒë·∫ßu v√†o l√† uint256

        return uint256((R * c) / 1e18); // Tr·∫£ v·ªÅ k·∫øt qu·∫£ cu·ªëi
    }

    /**
     * @dev T√¨m showroom g·∫ßn nh·∫•t v·ªõi t·ªça ƒë·ªô ng∆∞·ªùi d√πng
     * @param userLat Vƒ© ƒë·ªô c·ªßa ng∆∞·ªùi d√πng
     * @param userLon Kinh ƒë·ªô c·ªßa ng∆∞·ªùi d√πng
     * @return ƒê·ªãa ch·ªâ showroom g·∫ßn nh·∫•t
     */
    function findNearestShowroom(uint256 userLat, uint256 userLon) public view returns (address) {
        address nearestShowroom; // Bi·∫øn l∆∞u showroom g·∫ßn nh·∫•t

        for (uint256 i = 0; i < allShowrooms.length; i++) {
            address showroom = allShowrooms[i]; // L·∫•y showroom hi·ªán t·∫°i

            if (showroom == address(0) || showroomNodes[showroom].expiryDate < block.timestamp) {
                continue; // B·ªè qua showroom n·∫øu kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n
            }

            ShowroomTier tier = showroomNodes[showroom].tier; // L·∫•y c·∫•p b·∫≠c showroom

            if (tier == ShowroomTier.InActive) {
                continue; // B·ªè qua n·∫øu showroom ch∆∞a k√≠ch ho·∫°t
            }

            uint256 distance = calculateDistance(userLat, userLon, showroomNodes[showroom].lattitude, showroomNodes[showroom].longtitude); // T√≠nh kho·∫£ng c√°ch ƒë·∫øn showroom

            if (distance < safeRadius[tier]) { // N·∫øu trong b√°n k√≠nh an to√†n
                nearestShowroom = showroom; // Ch·ªçn showroom n√†y
                break; // Tho√°t v√≤ng l·∫∑p v√¨ ƒë√£ t√¨m ƒë∆∞·ª£c showroom g·∫ßn nh·∫•t
            }

            if (nearestShowroom == address(0) && distance < scanRadius[tier]) {
                nearestShowroom = showroom; // Ch·ªçn showroom n·∫øu kh√¥ng c√≥ showroom n√†o kh√°c g·∫ßn h∆°n
            }
        }

        return nearestShowroom; // Tr·∫£ v·ªÅ showroom g·∫ßn nh·∫•t t√¨m ƒë∆∞·ª£c
    }

    function plusCommision(address showroom, uint256 bp) public onlyTreeCommission returns (uint256) {
            if (showroomNodes[showroom].expiryDate <= block.timestamp) {
              return 0;
            }
            showroomNodes[showroom].totalBP += bp; // C·∫≠p nh·∫≠t t·ªïng BP showroom
            ShowroomTier tier = showroomNodes[showroom].tier; // L·∫•y c·∫•p b·∫≠c showroom
            uint256 comm = showroomCommissionRates[tier]; // L·∫•y % hoa h·ªìng showroom

            return comm;

    }
    function plusMember(address showroom, uint256 totalMember) public onlyTreeCommission returns (uint256) {
            if (showroomNodes[showroom].expiryDate <= block.timestamp) {
              return 0;
            }
            showroomNodes[showroom].totalMember += totalMember; // TƒÉng s·ªë th√†nh vi√™n showroom
            uint256 comm = showroomCommissionRates[showroomNodes[showroom].tier];

            return comm;

    }


    /**
     */
    function withdrawBP(uint256 amount) external onlyEOA {
        address showroom = msg.sender;
        uint256 preBalance = showroomNodes[showroom].totalBP;
        require(preBalance >= amount, "Insufficient balance");

        require(showroomNodes[showroom].expiryDate >= block.timestamp, "Showroom expired");

        ITreeCommission treeCommission = ITreeCommission(treeCommissionContract);
        treeCommission.withdrawBPToAnotherUser(amount, showroom);

    }

    /**
     * @dev Ki·ªÉm tra s·ªë d∆∞ hi·ªán t·∫°i c·ªßa Showroom
     */
    function getBalance() external view onlyEOA returns (uint256) {
        address showroom = msg.sender;
        require(showroomNodes[showroom].expiryDate >= block.timestamp, "Showroom expired");

        return showroomNodes[showroom].totalBP;
    }

}

/**
 * @title AgentLib
 * @dev Th∆∞ vi·ªán ch·ª©a c√°c h√†m x·ª≠ l√Ω Agent trong h·ªá th·ªëng TreeCommission
 */
library AgentLib {
    struct AgentData {
        uint256 level;
    }

    struct AgentStorage {
        mapping(address => AgentData) agents;
        uint256[] agentPercent;
    }

    /**
     * @dev Kh·ªüi t·∫°o danh s√°ch ph·∫ßn trƒÉm hoa h·ªìng cho c√°c c·∫•p Agent
     * @param self Struct ch·ª©a d·ªØ li·ªáu Agent
     */
    function initializeAgent(AgentStorage storage self) internal {
        self.agentPercent.push(0);   // C·∫•p 0: kh√¥ng nh·∫≠n hoa h·ªìng
        self.agentPercent.push(40);  // C·∫•p 1: 40%
        self.agentPercent.push(35);  // C·∫•p 2: 35%
        self.agentPercent.push(30);  // C·∫•p 3: 30%
        self.agentPercent.push(25);  // C·∫•p 4: 25%
    }

    /**
     * @dev C·∫≠p nh·∫≠t c·∫•p ƒë·ªô agent cho m·ªôt ng∆∞·ªùi d√πng
     * @param self Struct ch·ª©a d·ªØ li·ªáu Agent
     * @param user ƒê·ªãa ch·ªâ ng∆∞·ªùi d√πng
     * @param level C·∫•p ƒë·ªô agent m·ªõi
     */
    function setAgentLevel(AgentStorage storage self, address user, uint256 level) internal {
        require(level < self.agentPercent.length, "Invalid agent level");
        self.agents[user].level = level;
    }

    /**
     * @dev L·∫•y c·∫•p ƒë·ªô agent c·ªßa m·ªôt user
     * @param self Struct ch·ª©a d·ªØ li·ªáu Agent
     * @param user ƒê·ªãa ch·ªâ ng∆∞·ªùi d√πng
     * @return level C·∫•p ƒë·ªô c·ªßa agent
     */
    function getAgentLevel(AgentStorage storage self, address user) internal view returns (uint256) {
        return self.agents[user].level;
    }

    /**
     * @dev T√≠nh to√°n ph·∫ßn trƒÉm hoa h·ªìng cho agent d·ª±a v√†o c·∫•p ƒë·ªô
     * @param self Struct ch·ª©a d·ªØ li·ªáu Agent
     * @param user ƒê·ªãa ch·ªâ ng∆∞·ªùi d√πng
     * @param defaultPercent Ph·∫ßn trƒÉm m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng ph·∫£i Agent
     * @return percent Ph·∫ßn trƒÉm hoa h·ªìng t√≠nh ƒë∆∞·ª£c
     */
    function getAgentCommission(
        AgentStorage storage self,
        address user,
        uint256 defaultPercent
    ) internal view returns (uint256) {
        uint256 level = self.agents[user].level;
        return (level > 0) ? self.agentPercent[level] : defaultPercent;
    }
}

library TreeLib {

    uint256 public constant UNILEVEL_PERCENT_1 = 10; // 10% cho c·∫•p 1
    uint256 public constant UNILEVEL_PERCENT_2_TO_5 = 5; // 5% cho c·∫•p 2-5

    uint256 public constant PGrB_PERCENT = 2; // 2% hoa h·ªìng nh√≥m c√° nh√¢n
    uint256 public constant GeB_PERCENT = 3; // 3% hoa h·ªìng nh√≥m cho STL tr·ªü l√™n

    struct NodeInfo {
        address parent;
        address[] children;
        Rank rank;
        Status status;
        // address showroom;
    }

    struct NodeData {
        uint256 membershipExpiry;
        uint256 processedChildren;
        uint256 personalBP;
        uint256 teamBP;
        uint256 totalTeamBP;
        // uint256 personalGroupBP;
    }

    struct GenerationInfo {
        address gen1;
        address gen2;
        address gen3;
    }

    enum Rank {
        None,
        Manager,
        SeniorManager,
        TeamLeader,
        SeniorTeamLeader,
        Director,
        SeniorDirector,
        NationalDirector
    }

    enum Status {
        InActive,
        Active,
        Locked,
        Banned
    }

    /**
     * @dev C·∫≠p nh·∫≠t tr·∫°ng th√°i Active c·ªßa user d·ª±a v√†o ƒëi·ªÅu ki·ªán
     */


    
    function updateActiveStatus(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => NodeData) storage nodeData,
        mapping(address => uint256) storage membershipSoldThisMonth,
        mapping(address => uint256) storage productBPThisMonth,
        mapping(address => uint256) storage newMembershipInTeamThisMonth,
        address user
    ) internal returns (bool) {
        Status currentStatus = nodes[user].status;
        if (currentStatus == TreeLib.Status.Locked || currentStatus == TreeLib.Status.Banned) return false;

        if (block.timestamp > nodeData[user].membershipExpiry) {
            nodes[user].status = TreeLib.Status.Locked;
            return true;
        }

        /**
         * @dev Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒë·ªÉ m·ªôt user ƒë∆∞·ª£c coi l√† Active trong th√°ng.
         * M·ªôt Promoter ƒë∆∞·ª£c coi l√† Active n·∫øu th·ªèa m√£n √≠t nh·∫•t m·ªôt trong ba ƒëi·ªÅu ki·ªán sau:
         * 1. B√°n ƒë∆∞·ª£c √≠t nh·∫•t 1 membership m·ªõi trong th√°ng (membershipSoldThisMonth[user] >= 1)
         * 2. C√≥ √≠t nh·∫•t 10 membership m·ªõi ƒë∆∞·ª£c k√≠ch ho·∫°t trong team c·ªßa h·ªç trong th√°ng (newMembershipInTeamThisMonth[user] >= 10)
         * 3. ƒê·∫°t ƒë∆∞·ª£c √≠t nh·∫•t 100 BP t·ª´ doanh s·ªë b√°n s·∫£n ph·∫©m trong th√°ng (productBPThisMonth[user] >= 100)
         * 
         * N·∫øu m·ªôt trong c√°c ƒëi·ªÅu ki·ªán n√†y ƒë∆∞·ª£c ƒë√°p ·ª©ng, tr·∫°ng th√°i c·ªßa user s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t th√†nh Status.Active.
         */
        if (
          membershipSoldThisMonth[user] >= 1
          || newMembershipInTeamThisMonth[user] >= 10
          || productBPThisMonth[user] >= 100
        ) {
            nodes[user].status = Status.Active; // Active n·∫øu ƒë·∫°t ƒë·ªß ƒëi·ªÅu ki·ªán
            return true;
        }

        return false;
    }


    function setGenerationRank(
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        address user,
        uint8 groupRankIndex,
        address gen1,
        address gen2,
        address gen3
    ) internal {
        generationRank[user][groupRankIndex] = GenerationInfo(gen1, gen2, gen3);
    }


     /**
     * @dev ƒê·∫øm s·ªë ch√¢n active c·ªßa m·ªôt th√†nh vi√™n
     * @param nodes Mapping l∆∞u tr·ªØ th√¥ng tin node
     * @param user ƒê·ªãa ch·ªâ th√†nh vi√™n c·∫ßn ƒë·∫øm
     * @return S·ªë ch√¢n active
     */
    function countActiveLegs(mapping(address => NodeInfo) storage nodes, address user) internal view returns (uint256) {
        uint256 activeLegCount = 0;
        address[] storage children = nodes[user].children;
        for (uint256 i = 0; i < children.length; i++) {
            if (nodes[children[i]].status == Status.Active) {
                activeLegCount++;
            }
        }
        return activeLegCount;
    }

    /**
     * @dev C·∫≠p nh·∫≠t c·∫•p b·∫≠c cho m·ªôt th√†nh vi√™n d·ª±a tr√™n doanh s·ªë v√† s·ªë ch√¢n active
     * @param nodes Mapping l∆∞u tr·ªØ th√¥ng tin node
     * @param nodeData Mapping l∆∞u tr·ªØ th√¥ng tin node data
     * @param nationalDirectors M·∫£ng l∆∞u tr·ªØ danh s√°ch National Directors
     * @param user ƒê·ªãa ch·ªâ th√†nh vi√™n c·∫ßn c·∫≠p nh·∫≠t
     */
    function updateRanks(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => NodeData) storage nodeData,
        address[] storage nationalDirectors,
        address user
    ) internal {
        uint256 tgbp = nodeData[user].teamBP; // T·ªïng doanh s·ªë nh√≥m
        uint256 activeLegs = countActiveLegs(nodes, user); // S·ªë ch√¢n active

        // ƒêi·ªÅu ki·ªán n√¢ng c·∫•p b·∫≠c
        if (tgbp >= 100000 && activeLegs >= 7) {
            nodes[user].rank = Rank.NationalDirector;
            nationalDirectors.push(user);
        } else if (tgbp >= 50000 && activeLegs >= 6) {
            nodes[user].rank = Rank.SeniorDirector;
        } else if (tgbp >= 25000 && activeLegs >= 5) {
            nodes[user].rank = Rank.Director;
        } else if (tgbp >= 10000 && activeLegs >= 4) {
            nodes[user].rank = Rank.SeniorTeamLeader;
        } else if (tgbp >= 5000 && activeLegs >= 3) {
            nodes[user].rank = Rank.TeamLeader;
        } else if (tgbp >= 2500 && activeLegs >= 2) {
            nodes[user].rank = Rank.SeniorManager;
        } else if (activeLegs >= 1) {
            nodes[user].rank = Rank.Manager;
        }
    }

    /**
     * @dev C·∫≠p nh·∫≠t cha Active cho t·∫•t c·∫£ c√°c con c·ªßa m·ªôt user
     * @param nodes Mapping l∆∞u tr·ªØ th√¥ng tin node
     * @param activeParentMapping Mapping ƒë·ªÉ l∆∞u cha active
     * @param user ƒê·ªãa ch·ªâ th√†nh vi√™n c·∫ßn c·∫≠p nh·∫≠t
     */
    function updateActiveParentMapping(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => address) storage activeParentMapping,
        address user
    ) internal {
        address[] storage children = nodes[user].children;
        for (uint256 i = 0; i < children.length; i++) {
            activeParentMapping[children[i]] = user; // G√°n cha active
        }
    }

    function getGroupRank(mapping(address => NodeInfo) storage nodes, address user) internal view returns (uint8) {
        Rank rank = nodes[user].rank;
        if (rank == Rank.NationalDirector) return 3;
        if (rank == Rank.SeniorDirector) return 2;
        if (rank == Rank.Director) return 1;
        return 0; // SeniorTeamLeader v√† c√°c rank th·∫•p h∆°n
    }


    /**
    * @dev Ki·ªÉm tra xem m·ªôt ƒë·ªãa ch·ªâ `_child` c√≥ ph·∫£i l√† h·∫≠u du·ªá (descendant) c·ªßa ƒë·ªãa ch·ªâ `_ancestor` hay kh√¥ng,
    * v·ªõi ƒëi·ªÅu ki·ªán c√≥ gi·ªõi h·∫°n s·ªë t·∫ßng `totalLevel` v√† ph√¢n quy·ªÅn truy c·∫≠p ki·ªÉm tra.
    * 
    * Quy·ªÅn ki·ªÉm tra h·∫≠u du·ªá:
    * - Ng∆∞·ªùi g·ªçi h√†m ph·∫£i l√† `_ancestor` ho·∫∑c c√≥ quy·ªÅn xem c√¢y t·ª´ `_ancestor` (ƒë∆∞·ª£c l∆∞u tr·ªØ trong `linkViewTree`).
    *
    * N·∫øu ƒë√£ ki·ªÉm tra t·ªëi ƒëa `totalLevel` t·∫ßng m√† v·∫´n ch∆∞a t√¨m th·∫•y `_ancestor` trong c√¢y, h√†m s·∫Ω d·ª´ng v√† tr·∫£ v·ªÅ `false`.
    * N·∫øu `_ancestor` ƒë∆∞·ª£c t√¨m th·∫•y trong v√≤ng `totalLevel` t·∫ßng, h√†m s·∫Ω tr·∫£ v·ªÅ `true`.
    * 
    * @param _child ƒê·ªãa ch·ªâ c·ªßa th√†nh vi√™n c·∫ßn ki·ªÉm tra (ƒë·ª©a con).
    * @param _ancestor ƒê·ªãa ch·ªâ c·ªßa ng∆∞·ªùi c·∫ßn x√°c minh l√† t·ªï ti√™n (cha, √¥ng b√†...).
    * @param totalLevel Gi·ªõi h·∫°n s·ªë t·∫ßng c·∫ßn duy·ªát t·ª´ `_child` l√™n ƒë·∫øn `_ancestor`. D√πng ƒë·ªÉ t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t t√¨m ki·∫øm.
    * 
    * @return bool Tr·∫£ v·ªÅ `true` n·∫øu `_child` l√† h·∫≠u du·ªá c·ªßa `_ancestor` trong ph·∫°m vi s·ªë t·∫ßng `totalLevel`, ng∆∞·ª£c l·∫°i tr·∫£ v·ªÅ `false`.
    */
    function isDescendant(mapping(address => NodeInfo) storage nodes, address _child, address _ancestor, uint8 totalLevel, mapping(bytes32 => bool) storage linkViewTree, bytes32[] storage allLinkViewTreeKeys) internal returns (bool) {
        // require(_ancestor == msg.sender || linkViewTree[msg.sender + _ancestor] == true, "Not permitted");

        require(_ancestor == msg.sender || linkViewTree[keccak256(abi.encodePacked(msg.sender, _ancestor))] == true, "Not permitted");

        uint8 countLevel = 0; // Kh·ªüi t·∫°o b·ªô ƒë·∫øm t·∫ßng
        address current = _child; // B·∫Øt ƒë·∫ßu t·ª´ _child

        // Duy·ªát c√¢y t·ª´ _child l√™n theo h∆∞·ªõng cha -> con
        while (current != address(0)) {
            countLevel++; // TƒÉng s·ªë t·∫ßng khi di chuy·ªÉn l√™n

            // Ki·ªÉm tra xem ƒë√£ ƒë·∫øn gi·ªõi h·∫°n t·∫ßng ch∆∞a
            if (countLevel == totalLevel) {
                break;
            }

            // N·∫øu t√¨m th·∫•y _ancestor trong qu√° tr√¨nh duy·ªát
            if (current == _ancestor) {
                return true;
            }

            // Di chuy·ªÉn l√™n c√¢y (cha -> con)
            current = nodes[current].parent;

            // L∆∞u tr·∫°ng th√°i ƒë√£ ki·ªÉm tra c√¢y ƒë·∫øn t·∫ßng 10 ƒë·ªÉ t·ªëi ∆∞u h√≥a l·∫ßn ki·ªÉm tra ti·∫øp theo
            if (countLevel % 10 == 0) {
                bytes32 keyLinkView = keccak256(abi.encodePacked(msg.sender, current));
                linkViewTree[keyLinkView] = true;
                allLinkViewTreeKeys.push(keyLinkView);
            }
        }
        return false; // N·∫øu kh√¥ng t√¨m th·∫•y, tr·∫£ v·ªÅ false
    }



    /**
     * @dev T√¨m cha Active g·∫ßn nh·∫•t c·ªßa m·ªôt user
     * - Duy·ªát ng∆∞·ª£c t·ª´ node hi·ªán t·∫°i l√™n ƒë·∫øn root.
     * - N·∫øu g·∫∑p m·ªôt node Active, tr·∫£ v·ªÅ node ƒë√≥.
     * - S·ª≠ d·ª•ng `activeParentMapping` ƒë·ªÉ t·ªëi ∆∞u t·ªëc ƒë·ªô t√¨m ki·∫øm (O(1)).
     */
    function findActiveParent(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => address) storage activeParentMapping,
        address user
    ) internal view returns (address) {
        address current = nodes[user].parent; // B·∫Øt ƒë·∫ßu t·ª´ cha c·ªßa user
        while (current != address(0)) { // Duy·ªát l√™n ƒë·∫øn khi g·∫∑p root (address(0))
            if (nodes[current].status == Status.Active) return current; // Tr·∫£ v·ªÅ node Active ƒë·∫ßu ti√™n t√¨m th·∫•y
            current = activeParentMapping[current]; // Di chuy·ªÉn l√™n cha Active ti·∫øp theo trong mapping
        }
        return address(0); // N·∫øu kh√¥ng t√¨m th·∫•y cha Active n√†o
    }

    /**
     * @dev Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒë·ªÉ m·ªôt user ƒë∆∞·ª£c xem l√† Active
     * - ƒêi·ªÅu ki·ªán: Personal BP >= 100 ho·∫∑c Team BP >= 500.
     * @param user ƒê·ªãa ch·ªâ c·ªßa user c·∫ßn ki·ªÉm tra
     * @return Tr·∫£ v·ªÅ `true` n·∫øu user ƒë√°p ·ª©ng ƒëi·ªÅu ki·ªán, ng∆∞·ª£c l·∫°i `false`
     */
    function checkActiveCondition(mapping(address => NodeData) storage nodeData, address user) internal view returns (bool) {
        return nodeData[user].personalBP >= 100 || nodeData[user].teamBP >= 500;
    }

    /**
     * @dev C·∫≠p nh·∫≠t Team BP c·ªßa user d·ª±a v√†o c√°c node con
     */
    function updateTeamBP(
        mapping(address => NodeData) storage nodeData,
        mapping(address => NodeInfo) storage nodes,
        address[] storage nationalDirectors,
        address user
    ) internal {

        // To-Do: s·ª≠a l·∫°i nh∆∞ code po5 c≈©
        uint256 totalBP = nodeData[user].personalBP; // T·ªïng BP t·ª´ t·∫•t c·∫£ c√°c ch√¢n v√† c·ªßa ch√≠nh user
        uint256 totalPersonalGroupBP = 0; // T·ªïng BP c·ªßa nh√≥m c√° nh√¢n

        uint256 totalChild = nodes[user].children.length; // S·ªë l∆∞·ª£ng node con

        uint256[] memory childBPs = new uint256[](totalChild); // M·∫£ng l∆∞u BP t·ª´ng ch√¢n
        for (uint256 i = 0; i < totalChild; i++) {
            address childUser = nodes[user].children[i]; // L·∫•y ƒë·ªãa ch·ªâ node con
            NodeInfo storage nodeChildUser = nodes[childUser]; // L·∫•y th√¥ng tin node con
            
            uint256 teamBP = nodeData[childUser].personalBP + nodeData[childUser].teamBP; // L·∫•y BP c·ªßa node con

            if (teamBP <= 0) {
                continue; // B·ªè qua n·∫øu BP = 0
            }


            // x√©t l·∫°i l√† 0 ƒë·ªÉ kh√¥ng b·ªã l·∫∑p l·∫°i
            nodeData[childUser].teamBP = 0;

            childBPs[i] = teamBP; // L∆∞u BP c·ªßa ch√¢n hi·ªán t·∫°i
            totalBP += teamBP; // C·ªông v√†o t·ªïng BP

            // N·∫øu rank c·ªßa node con < SeniorTeamLeader, c·ªông v√†o t·ªïng BP nh√≥m c√° nh√¢n
            if (nodeChildUser.rank < Rank.SeniorTeamLeader) {
                totalPersonalGroupBP += teamBP;
            }
        }
        
        if (totalBP > 0) {

            // √Åp d·ª•ng gi·ªõi h·∫°n t·ªëi ƒëa t·ª´ ch√¢n m·∫°nh
            uint256 maxPercentage = (nodes[user].rank >= Rank.Director) ? 40 : 50;
            uint256 maxBPPerLeg = (totalBP * maxPercentage) / 100; // Gi·ªõi h·∫°n BP theo %
            uint256 adjustedBP = 0; // BP sau khi √°p d·ª•ng gi·ªõi h·∫°n
            
            for (uint256 i = 0; i < totalChild; i++) {
                adjustedBP += (childBPs[i] > maxBPPerLeg) ? maxBPPerLeg : childBPs[i];
            }

            // N·∫øu c√≥ thay ƒë·ªïi v·ªÅ BP, c·∫≠p nh·∫≠t rank
            uint256 increaseBP = adjustedBP - nodeData[user].teamBP;
            if (increaseBP > 0) {
                nodeData[user].teamBP = adjustedBP; // C·∫≠p nh·∫≠t TeamBP
                updateRanks(nodes, nodeData, nationalDirectors, user); // C·∫≠p nh·∫≠t rank
            }

            nodeData[user].totalTeamBP = totalBP; // L∆∞u t·ªïng BP
        }
    }

    /**
     * @dev Ph√¢n ph·ªëi hoa h·ªìng Unilevel cho c√°c c·∫•p
     */
     function distributeUnilevelBonus(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => address) storage activeParentMapping,
        BalancesManager balancesManager,
        address user,
        uint256 bp,
        bytes32 utxoID
    ) internal {
        address current = activeParentMapping[user]; // B·∫Øt ƒë·∫ßu t·ª´ cha Active c·ªßa user
        uint8 level = 1; // C·∫•p hi·ªán t·∫°i


        address[] memory users;
        uint256[] memory amounts;
        uint256 counBatchUpdateBalances = 0; // Bi·∫øn ƒë·∫øm s·ªë ph·∫ßn t·ª≠


        while (level <= 5 && current != address(0)) { // Duy·ªát t·ªëi ƒëa 5 c·∫•p
            uint256 percent = (level == 1) ? UNILEVEL_PERCENT_1 : UNILEVEL_PERCENT_2_TO_5; // X√°c ƒë·ªãnh % th∆∞·ªüng theo c·∫•p
            uint256 commission = (bp * percent) / 100; // T√≠nh s·ªë ti·ªÅn th∆∞·ªüng

            // balances[current] += commission; // C·ªông th∆∞·ªüng v√†o balance c·ªßa node hi·ªán t·∫°i
            if (nodes[current].status != TreeLib.Status.Locked) {
              users[counBatchUpdateBalances] = current;
              amounts[counBatchUpdateBalances] = commission;
              counBatchUpdateBalances++;
            }

            // emit BPChanged(current, bp); // Emit s·ª± ki·ªán khi thay ƒë·ªïi BP

            current = activeParentMapping[current]; // L√™n c·∫•p ti·∫øp theo
            level++;
        }
        balancesManager.batchUpdateBalances(utxoID, users, amounts, true);
    }
    function distributeGenerationBonus_batchUpdate(
        // mapping(address => NodeInfo) storage nodes,
        BalancesManager balancesManager,
        bytes32 utxoID,
        uint256 bp,
        address personalGroup,
        address gen1,
        address gen2,
        address gen3
      ) internal {
        

        address[] memory users;
        uint256[] memory amounts;
        uint256 counBatchUpdateBalances = 0; // Bi·∫øn ƒë·∫øm s·ªë ph·∫ßn t·ª≠

        // ki·ªÉm tra l·∫°i tr·∫°ng th√°i active
        // if (nodes[personalGroup].status == TreeLib.Status.Locked) {
        //   personalGroup = address(0);
        // }
        // if (nodes[gen1].status == TreeLib.Status.Locked) {
        //   gen1 = address(0);
        // }
        // if (nodes[gen2].status == TreeLib.Status.Locked) {
        //   gen2 = address(0);
        // }
        // if (nodes[gen3].status == TreeLib.Status.Locked) {
        //   gen3 = address(0);
        // }


        // tr·∫£ cho hoa h·ªìng personal Groups, 2%
        if (personalGroup != address(0)) {
          users[counBatchUpdateBalances] = personalGroup;
          amounts[counBatchUpdateBalances] = (bp * PGrB_PERCENT) / 100;
          counBatchUpdateBalances++;
        }

        if (gen1 != address(0)) {
            users[counBatchUpdateBalances] = gen1;
            amounts[counBatchUpdateBalances] = (bp * GeB_PERCENT) / 100;
            counBatchUpdateBalances++;
        }

        if (gen2 != address(0)) {
            users[counBatchUpdateBalances] = gen2;
            amounts[counBatchUpdateBalances] = (bp * GeB_PERCENT) / 100;
            counBatchUpdateBalances++;
        }

        if (gen3 != address(0)) {
            users[counBatchUpdateBalances] = gen3;
            amounts[counBatchUpdateBalances] = (bp * GeB_PERCENT) / 100;
            counBatchUpdateBalances++;
        }



        if (users.length > 0 ) {
          balancesManager.batchUpdateBalances(utxoID, users, amounts, true);
        }

      }
    function distributeGenerationBonus(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        mapping(address => address) storage personalGroups,
        BalancesManager balancesManager,
        address user,
        uint256 bp,
        bytes32 utxoID
      ) internal {


        // address[] memory users;
        // uint256[] memory amounts;
        // uint256 counBatchUpdateBalances = 0; // Bi·∫øn ƒë·∫øm s·ªë ph·∫ßn t·ª≠

        address parent = nodes[user].parent;
        uint8 groupRankIndex = TreeLib.getGroupRank(nodes, user);

        TreeLib.Rank currentRank = nodes[user].rank;

        address personalGroup = address(0);

        address gen1 = address(0);
        address gen2 = address(0);
        address gen3 = address(0);

        if ( groupRankIndex > 0 ) {

          personalGroup = address(0);

          if (currentRank == TreeLib.Rank.Director) {
            gen2 = generationRank[parent][groupRankIndex].gen2;
            gen3 = generationRank[parent][groupRankIndex].gen3;
          } else if (currentRank == TreeLib.Rank.SeniorDirector) {
            gen3 = generationRank[parent][groupRankIndex].gen3;
          }
        } else {
          personalGroup = personalGroups[parent];

          gen1 = generationRank[parent][groupRankIndex].gen1;
          gen2 = generationRank[parent][groupRankIndex].gen2;
          gen3 = generationRank[parent][groupRankIndex].gen3;
        }

        distributeGenerationBonus_batchUpdate(balancesManager, utxoID, bp, personalGroup, gen1, gen2, gen3);
    }

    /**
     * @dev C·∫≠p nh·∫≠t `generationRank` cho user
     */
    function setInheritGenerationRank(
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        address parent,
        address user,
        uint8 groupRankIndex
    ) internal {
        if (parent == address(0)) return;
        
        GenerationInfo storage parentGenInfo = generationRank[parent][groupRankIndex];


        generationRank[user][groupRankIndex] = GenerationInfo(
            parentGenInfo.gen1,
            parentGenInfo.gen2,
            parentGenInfo.gen3
        );
    }

    function distributeNationalBonus(
    //   mapping(address => NodeInfo) storage nodes,
      BalancesManager balancesManager,
      address[] storage nationalDirectors
    ) internal {

        uint256 nationalBonusPool = balancesManager.getNationalBonusPool();


        uint256 totalDirectors = nationalDirectors.length;
        require(totalDirectors > 0, "No National Directors to distribute");

        uint256 bonusPerDirector = nationalBonusPool / totalDirectors;
        require(bonusPerDirector > 0, "Insufficient pool");

        // Reset pool sau khi chia th∆∞·ªüng
        balancesManager.resetNationalBonusPool(nationalBonusPool);
        

        address[] memory users;
        uint256[] memory amounts;
        uint256 counBatchUpdateBalances = 0; // Bi·∫øn ƒë·∫øm s·ªë ph·∫ßn t·ª≠

        for (uint256 i = 0; i < totalDirectors; i++) {
            
            // if (nodes[director].status == TreeLib.Status.Locked) {
            //   continue;
            // }
            users[counBatchUpdateBalances] = nationalDirectors[i];
            amounts[counBatchUpdateBalances] = bonusPerDirector;
            counBatchUpdateBalances++;
        }

        balancesManager.batchUpdateBalances(bytes32(0), users, amounts, true);

        // emit NationalBonusDistributed(nationalBonusPool, totalDirectors);

    }

    /**
    
    * **L∆∞u √Ω:**
    * Ph√π h·ª£p v·ªõi batch 24h ƒë·ªÉ ƒë·ªìng b·ªô to√†n b·ªô h·ªá th·ªëng.
    *
    * @dev C·∫≠p nh·∫≠t `generationRank` t·ª´ `rootNode` xu·ªëng to√†n b·ªô c√¢y MLM.
    *      H√†m n√†y s·ª≠ d·ª•ng ƒë·ªá quy ƒë·ªÉ duy·ªát to√†n b·ªô c√¢y v√† c·∫≠p nh·∫≠t th·∫ø h·ªá nh·∫≠n th∆∞·ªüng (`gen1`, `gen2`, `gen3`)
    *      theo h·ªá th·ªëng c·∫•p b·∫≠c (`Director`, `Senior Director`, `National Director`).
    *
    * **Thu·∫≠t to√°n x·ª≠ l√Ω:**
    * 1. N·∫øu `current` l√† `rootNode`, kh·ªüi t·∫°o t·∫•t c·∫£ `gen1`, `gen2`, `gen3` v·ªÅ `address(0)`.
    * 2. N·∫øu `current` c√≥ c·∫•p b·∫≠c ·∫£nh h∆∞·ªüng (`Director`, `Senior Director`, `National Director`):
    *    - N·∫øu `National Director`: `gen1 = gen2 = gen3 = current`
    *    - N·∫øu `Senior Director`:  `gen1 = current`, `gen2 = current`, `gen3 = generationRank[parent].gen3`
    *    - N·∫øu `Director`:         `gen1 = current`, `gen2 = generationRank[parent].gen2`, `gen3 = generationRank[parent].gen3`
    * 3. N·∫øu `current` kh√¥ng c√≥ rank ·∫£nh h∆∞·ªüng, k·∫ø th·ª´a `generationRank` t·ª´ `parent`.
    * 4. ƒê·ªá quy xu·ªëng c√°c `children` ƒë·ªÉ ti·∫øp t·ª•c c·∫≠p nh·∫≠t `generationRank`.
    *
    * **ƒêi·ªÅu ki·ªán ki·ªÉm tra:**
    * - N·∫øu `parent == address(0)`, nghƒ©a l√† d·ªØ li·ªáu b·ªã l·ªói ‚Üí G·ªçi `revert("Parent lost during reset!")`
    *   ƒë·ªÉ d·ª´ng to√†n b·ªô h·ªá th·ªëng nh·∫±m tr√°nh d·ªØ li·ªáu sai l·ªách.
    *
    * **V√≠ d·ª• v·ªÅ h·ªá th·ªëng MLM:**
    *
    * Gi·∫£ s·ª≠ h·ªá th·ªëng MLM c√≥ c·∫•u tr√∫c c√¢y nh∆∞ sau:
    *
    * ```
    *      A (National Director)
    *      /                 \
    *    B (Director)         C (Senior Director)
    *   /     \                \
    *  D       E (Director).    F (Senior Director)
    * ```
    *
    * **C·∫•p b·∫≠c ·∫£nh h∆∞·ªüng c·ªßa m·ªói node:**
    * - `A`: National Director
    * - `B`: Director
    * - `C`: Senior Director
    * - `E`: Director
    * - `D` v√† `F` kh√¥ng c√≥ rank
    *
    * **Sau khi ch·∫°y `updateGenerationRankFromRoot(A)`, d·ªØ li·ªáu c·∫≠p nh·∫≠t nh∆∞ sau:**
    *
    * ```
    * +---------------------+------+------+------+
    * | Node               | gen1 | gen2 | gen3 |
    * +---------------------+------+------+------+
    * | A (National Dir.)  | A    | A    | A    |
    * | B (Director)       | B    | A    | A    |
    * | C (Senior Dir.)    | C    | C    | A    |
    * | D (Kh√¥ng c√≥ rank)  | B    | A    | A    |
    * | E (Director)       | E    | A    | A    |
    * | F (Senior Dir.)    | F    | F    | A    |
    * +---------------------+------+------+------+
    * ```
    *
    * **Gi·∫£i th√≠ch t·∫°i sao `gen2 = parent.gen2` v√† `gen3 = parent.gen3` v·ªõi Director:**
    * - N·∫øu `E` l√† `Director`, `gen1 = E` (do ch√≠nh n√≥ l√† ng∆∞·ªùi h∆∞·ªüng hoa h·ªìng ƒë·∫ßu ti√™n).
    * - `gen2` c·ªßa `E` ph·∫£i l√† `A`, v√¨ `A` l√† c·∫•p cao nh·∫•t g·∫ßn nh·∫•t, v√† ƒëi·ªÅu n√†y ƒë∆∞·ª£c k·∫ø th·ª´a t·ª´ `gen2` c·ªßa `parent`.
    * - `gen3` c·ªßa `E` c≈©ng ph·∫£i l√† `A`, v√¨ h·ªá th·ªëng MLM ph·∫£i ƒë·∫£m b·∫£o duy tr√¨ ƒë√∫ng c·∫•p cao nh·∫•t g·∫ßn nh·∫•t.
    * - N·∫øu d√πng `gen2 = parent.gen1`, c√≥ th·ªÉ g√¢y l·ªói m·∫•t c·∫•p b·∫≠c v√† l√†m sai logic MLM.
    *

    */

    function updateGenerationRank(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        mapping(address => address) storage personalGroups,
        address rootNode, address current
    ) internal {

        Rank currentRank = nodes[current].rank;

        if (current == rootNode) {

          for (uint8 groupIndex = 0; groupIndex < 4; groupIndex++) {
            setGenerationRank(generationRank, current, groupIndex, address(0), address(0), address(0));
          }

        } else if (
          // currentRank == Rank.SeniorTeamLeader || 
          currentRank == Rank.Director
          || currentRank == Rank.SeniorDirector
          || currentRank == Rank.NationalDirector
        ) { // v·ªõi c√°c rank m√† c√≥ ·∫£nh h∆∞·ªüng , th√¨ c·∫ßn x√©t l·∫°i gen1, gen2, gen3

          personalGroups[current] = current;

          address parent = nodes[current].parent;
          if (parent == address(0)) {
            //   string memory logMessage = string(
            //       abi.encodePacked(
            //           "updateGenerationRank failed: Parent lost during reset, user ", Strings.toHexString(uint256(uint160(current)), 20),
            //           ", currentRank: ", Strings.toString(uint256(currentRank))
            //       )
            //   );
            //   eventLoggerManager.recordEvent("updateGenerationRank", logMessage);
              revert("Parent lost during reset!");
          }

          for (uint8 groupIndex = 0; groupIndex < 4; groupIndex++) {

            address gen1;
            address gen2;
            address gen3;

            if (currentRank == Rank.NationalDirector) {
                gen3 = current;
                gen2 = current;
                gen1 = current;
            } else if (currentRank == Rank.SeniorDirector) {
                gen3 = generationRank[parent][groupIndex].gen3;
                gen2 = current;
                gen1 = current;
            } else {
                // currentRank == Rank.Director
                gen3 = generationRank[parent][groupIndex].gen3;
                gen2 = generationRank[parent][groupIndex].gen2;
                gen1 = current;
            }

            setGenerationRank(generationRank, current, groupIndex, gen1, gen2, gen3);
          }

        } else { // d√†nh cho c√°c node m√† kh√¥ng c√≥ rank ·∫£nh h∆∞·ªüng ƒë·∫øn child, th√¨ l·∫•y parent c·ªßa node ƒë√≥ g√°n v√†o


          address parent = nodes[current].parent;
          if (parent == address(0)) {
            // string memory logMessage = string(
            //     abi.encodePacked(
            //         "updateGenerationRank failed: Parent lost during reset, user ", Strings.toHexString(uint256(uint160(current)), 20),
            //         ", currentRank: ", Strings.toString(uint256(currentRank))
            //     )
            // );
            // eventLoggerManager.recordEvent("updateGenerationRank", logMessage);
            revert("Parent lost during reset!");
          }

          for (uint8 groupIndex = 0; groupIndex < 4; groupIndex++) {
            // generationRank[current][groupIndex] = generationRank[parent][groupIndex];
            setInheritGenerationRank(generationRank, parent, current, groupIndex);
          }

          if (
            currentRank == Rank.SeniorTeamLeader
          ) {
            personalGroups[current] = current;
          } else {
            personalGroups[current] = parent;
          }

        }

        // ƒê·ªá quy xu·ªëng children
        address[] storage children = nodes[current].children;
        for (uint i = 0; i < children.length; i++) {
            // updateGenerationRank(nodes, rootNode, children[i]);
            updateGenerationRank(nodes, generationRank, personalGroups, rootNode, children[i]);
        }
    }

    function isValidUTXO(bytes32 utxoID) internal pure returns (bool) {
        return utxoID != bytes32(0);
    }

    function checkTransferUSDT(IERC20 usdtToken, bytes32 utxoID, uint256 usdtAmount) internal {

        if (isValidUTXO(utxoID)) {
            
        } else {

            // Ki·ªÉm tra s·ªë d∆∞ USDT tr∆∞·ªõc giao d·ªãch
            uint256 balanceBefore = usdtToken.balanceOf(address(this));

            // Y√™u c·∫ßu chuy·ªÉn USDT t·ª´ user v√†o h·ª£p ƒë·ªìng
            require(usdtToken.transferFrom(msg.sender, address(this), usdtAmount), "USDT transfer failed");

            // Ki·ªÉm tra s·ªë d∆∞ USDT sau giao d·ªãch
            uint256 balanceAfter = usdtToken.balanceOf(address(this));
            uint256 receivedUSDT = balanceAfter - balanceBefore;

            // ƒê·∫£m b·∫£o s·ªë d∆∞ USDT tƒÉng ƒë√∫ng s·ªë l∆∞·ª£ng user ƒë√£ g·ª≠i, v·ªõi sai s·ªë ¬±1 USDT (ƒë∆°n v·ªã 6 ch·ªØ s·ªë th·∫≠p ph√¢n)
            require(receivedUSDT >= usdtAmount - 1e6 && receivedUSDT <= usdtAmount + 1e6, "Incorrect USDT transfer amount");

        }
    }

}

/**
 * @title TreeCommission
 * @dev H·ª£p ƒë·ªìng th√¥ng minh MLM "Power of 5" tri·ªÉn khai k·∫ø ho·∫°ch th∆∞·ªüng v·ªõi nhi·ªÅu lo·∫°i hoa h·ªìng,
 * qu·∫£n l√Ω th√†nh vi√™n v√† x·ª≠ l√Ω batch ƒë·ªÉ t·ªëi ∆∞u h√≥a gas.
 */
contract TreeCommission is ITreeCommission {
    using AgentLib for AgentLib.AgentStorage;
    AgentLib.AgentStorage private agentStorage;

    using TreeLib for mapping(address => TreeLib.NodeInfo);
    using TreeLib for mapping(address => TreeLib.NodeData);
    // using TreeLib for mapping(address => TreeLib.GenerationInfo);



    // mapping(address => uint256) public agentLevel;


    /**
     * @dev M·∫£ng l∆∞u ph·∫ßn trƒÉm hoa h·ªìng cho c√°c c·∫•p b·∫≠c Agent
     */
    // uint256[] public agentPercent;

    /**
     * @dev Gi√° tr·ªã ph·∫ßn ngh√¨n cho hoa h·ªìng c·ªßa Agent (t√≠nh theo ƒë∆°n v·ªã ph·∫ßn ngh√¨n)
     */
    uint256 internal constant AGENT_FW_PERMILLE = 325; // 32.5%

    // C√°c ph√≠ v√† bonus ƒë∆∞·ª£c t√≠nh theo ƒë∆°n v·ªã USDT 1e6
    uint256 internal constant ACTIVATION_FEE = 40 * 1e6; // Ph√≠ k√≠ch ho·∫°t $40
    uint256 internal constant ACTIVATION_BP = 10; // 10 BP khi k√≠ch ho·∫°t

    uint256 internal constant MEMBERSHIP_FEE = 120 * 1e6; // Ph√≠ th√†nh vi√™n $120
    uint256 internal constant MEMBERSHIP_BP = 100; // 100 BP cho m·ªói l·∫ßn b√°n th√†nh vi√™n

    // Ph·∫ßn trƒÉm hoa h·ªìng cho c√°c h·∫°ng m·ª•c kh√°c nhau
    uint256 internal constant STOCK_COMMISSION_PERCENT = 20; // 20% cho hoa h·ªìng b√°n l·∫ª
    uint256 internal constant DAO_COMMISSION_PERCENT = 4;    // 4% cho DAO
    uint256 internal constant RETAIL_COMMISSION_PERCENT = 20; // 20% cho hoa h·ªìng b√°n l·∫ª
    uint256 internal constant SHOWROOM_COMMISSION_PERCENT = 1; // 1% cho showroom
    uint256 internal constant SHOWROOM_BONUS = 20; // Bonus $20 cho showroom g·∫ßn nh·∫•t

    // Ph·∫ßn trƒÉm hoa h·ªìng Unilevel cho c√°c c·∫•p trong h·ªá th·ªëng MLM
    // uint256 internal constant UNILEVEL_PERCENT_1 = 10; // 10% cho c·∫•p 1
    // uint256 internal constant UNILEVEL_PERCENT_2_TO_5 = 5; // 5% cho c·∫•p 2-5
    // uint256 internal constant PGrB_PERCENT = 2; // 2% hoa h·ªìng nh√≥m c√° nh√¢n
    // uint256 internal constant GeB_PERCENT = 3; // 3% hoa h·ªìng nh√≥m cho STL tr·ªü l√™n

    // Gi·ªõi h·∫°n ph·∫ßn trƒÉm t·ª´ m·ªôt ch√¢n ƒë·ªÉ tr√°nh hi·ªán t∆∞·ª£ng ch√¢n m·∫°nh
    uint256 internal constant MAX_LEG_PERCENTAGE = 50; // 50% cho c√°c c·∫•p d∆∞·ªõi Director
    uint256 internal constant MAX_LEG_PERCENTAGE_DIRECTOR = 40; // 40% cho Director tr·ªü l√™n

    uint256 internal constant NATIONAL_BONUS_POOL_PERCENT = 2; // 2% hoa h·ªìng ƒë·ªï v√†o pool cho RANK BASES NATIONAL BONUS POOL (2% of BP), m·ªói ng√†y s·∫Ω l·∫•y ra chia cho t·∫•t c·∫£ th√†nh vi√™n ƒë·∫°t c·∫•p National Director

    address[] internal nationalDirectors;
    // event NationalBonusDistributed(uint256 totalPool, uint256 totalDirectors);



    /**
     * @dev Struct cho VIPNode (th√†nh vi√™n ch·ªù k√≠ch ho·∫°t)
     */
    struct VIPNode {
        address parent;               // Cha c·ªßa VIPNode
        uint256 membershipExpiry;     // Th·ªùi gian h·∫øt h·∫°n membership
    }

    // Danh s√°ch node v√† mapping l∆∞u th√¥ng tin node
    address[] internal allNodes;
    // mapping(address => NodeInfo) public nodes;
    // mapping(address => NodeData) public nodeData;

    mapping(address => TreeLib.NodeInfo) private nodes;
    mapping(address => TreeLib.NodeData) private nodeData;
    

    mapping(address => address) private memberInShowroom;
    
    // L∆∞u s·ªë l∆∞·ª£ng membership ƒë√£ b√°n trong th√°ng cho t·ª´ng user
    mapping(address => uint256) internal membershipSoldThisMonth;

    // L∆∞u ƒëi·ªÉm BP s·∫£n ph·∫©m trong th√°ng cho t·ª´ng user
    mapping(address => uint256) internal productBPThisMonth;

    mapping(address => uint256) internal newMembershipInTeamHour;
    mapping(address => uint256) internal newMembershipInTeamThisMonth; // Th√™m bi·∫øn ƒë·ªôc l·∫≠p ƒë·ªÉ ghi nh·∫≠n 10 membership m·ªõi trong team

    mapping(address => address) private personalGroups; // Mapping cha hoa h·ªìng th·∫ø h·ªá peronal group
    mapping(address => address) private activeParentMapping; // Mapping cha Active

    // mapping(address => TreeLib.GenerationInfo) private generationRank;
    mapping(address => mapping(uint8 => TreeLib.GenerationInfo)) private generationRank;



    // Danh s√°ch leafNodes (node l√°)
    address[] internal leafNodes;

    /**
     * @dev Struct l∆∞u th√¥ng tin th√†nh vi√™n m·ªõi trong queue
     */
    struct NewMember {
        address newMember;      // Th√†nh vi√™n m·ªõi
        address parent;         // Cha
        uint256 longtitude;     // Kinh ƒë·ªô
        uint256 lattitude;      // Vƒ© ƒë·ªô
        bytes32 utxoID;
    }

    /**
     * @dev Struct l∆∞u th√¥ng tin giao d·ªãch b√°n h√†ng trong queue
     */
    struct SalesRecord {
        address user;           // Ng∆∞·ªùi d√πng
        uint256 bp;             // S·ªë BP
        bytes32 utxoID;
    }

    // Queue cho x·ª≠ l√Ω batch: th√†nh vi√™n m·ªõi v√† giao d·ªãch
    NewMember[] internal newMemberQueue;
    SalesRecord[] internal salesQueue;

    bool internal isBatchProcessing = false; // C·ªù b√°o hi·ªáu ƒëang x·ª≠ l√Ω batch
    bool internal isLockData = false;        // C·ªù b√°o hi·ªáu ƒëang kh√≥a d·ªØ li·ªáu

    // Mapping v√† danh s√°ch VIPNode
    mapping(address => VIPNode) internal vipNodes;
    mapping(address => address[]) internal vipNodesList;

    // S·ª± ki·ªán khi th√™m VIP v√† Promoter
    // event VIPAdded(address indexed user, address indexed parent);
    // event PromoterAdded(address indexed user, address indexed parent);

    // C√°c ƒë·ªãa ch·ªâ quan tr·ªçng trong h·ªá th·ªëng
    address rootNode;
    address daoNode;
    address stockNode;

    IERC20 internal usdtToken; // Token USDT s·ª≠ d·ª•ng trong h·ªá th·ªëng
    address owner;

    event BPChanged(address indexed user, uint256 bp);


    struct SalesData {
        uint256 totalBP;
        bool exists;
    }

    mapping(address => SalesData) internal hourlySales;
    mapping(address => bool) internal hasSales; // Bi·∫øn c·ªù ƒë·ªôc l·∫≠p ƒë·ªÉ l∆∞u b·ªï sung cho user k·∫ø th·ª´a doanh s·ªë ph√°t sinh t·ª´ nh√°nh d∆∞·ªõi



    BalancesManager internal balancesManager;
    Showroom internal showroomManager;
    EventLogger internal eventLoggerManager;

    mapping(bytes32 => bool) internal linkViewTree;
    bytes32[] internal allLinkViewTreeKeys; // Danh s√°ch l∆∞u tr·ªØ t·∫•t c·∫£ c√°c kh√≥a


    /**
     * @dev H√†m kh·ªüi t·∫°o h·ª£p ƒë·ªìng th√¥ng minh TreeCommission
     * @param _usdtAddress ƒê·ªãa ch·ªâ c·ªßa h·ª£p ƒë·ªìng token USDT
     */
    constructor(address _balanceManagerAddress, address _showroomAddress, address _eventLoggerAddress, address _rootNodeAddress, address _daoNodeAddress, address _stockNodeAddress, address _usdtAddress) {
        // Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa MEMBERSHIP_BP (tr√°nh l·ªói do l·∫≠p tr√¨nh sai)
        require(MEMBERSHIP_BP * 1e6 < MEMBERSHIP_FEE, "wrong code");

        balancesManager = BalancesManager(_balanceManagerAddress);
        showroomManager = Showroom(_showroomAddress);
        eventLoggerManager = EventLogger(_eventLoggerAddress);

        // G√°n ƒë·ªãa ch·ªâ h·ª£p ƒë·ªìng USDT cho bi·∫øn usdtToken
        usdtToken = IERC20(_usdtAddress);


        rootNode = _rootNodeAddress;
        daoNode = _daoNodeAddress;
        stockNode = _stockNodeAddress;

        owner = msg.sender;

        // Kh·ªüi t·∫°o ph·∫ßn trƒÉm hoa h·ªìng cho c√°c c·∫•p Agent
        agentStorage.initializeAgent();

        nodes[rootNode].status = TreeLib.Status.Active;


    }
    

     /**
     * @dev Modifier `onlyOwner` gi·ªõi h·∫°n quy·ªÅn truy c·∫≠p cho ch·ªß s·ªü h·ªØu
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Ownable: caller is not the owner"); // Ki·ªÉm tra ng∆∞·ªùi g·ªçi l√† ch·ªß s·ªü h·ªØu
        _;
    }

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }

    /**
     * @dev Kh√≥a d·ªØ li·ªáu trong h·ªá th·ªëng
     * - Kh√¥ng cho ph√©p th√™m m·ªõi, ch·ªânh s·ª≠a d·ªØ li·ªáu khi ƒëang ch·∫°y batch.
     * - Ch·ªâ ƒë∆∞·ª£c th·ª±c thi n·∫øu h·ªá th·ªëng khi batch kh√¥ng ch·∫°y
     */
    function setLockData(bool isLock) external onlyOwner {
        require(!isBatchProcessing, "Batch processing is running"); // Ki·ªÉm tra ƒëang batch

        isLockData = isLock; // Kh√≥a d·ªØ li·ªáu
    }

    // function getUserStatus(address user) external view returns (uint256) {
    //     return uint256(nodes[user].status);
    // }
 
    function banUser(address user) external onlyOwner {
        nodes[user].status = TreeLib.Status.Banned;
    }


    function withdrawBPToUser(uint256 amount, address user) internal {
        uint256 preBalance = balancesManager.getBalance(msg.sender);
        require(preBalance >= amount, "Insufficient balance");

        TreeLib.Status userStatus = nodes[msg.sender].status;
        require(userStatus != TreeLib.Status.Locked && userStatus != TreeLib.Status.Banned, "Deny access");

        require(balancesManager.withdrawBP(msg.sender, amount), "Insufficient balance for withdraw");

        require(usdtToken.transfer(user, amount), "Transfer failed");

        // uint256 lastBalance = balancesManager.getBalance(msg.sender);

        // #debug t·∫°m ·∫©n ƒë·ªÉ ko b·ªã warning code
        // if (lastBalance != preBalance - amount) {
        //     string memory logMessage = string(
        //         abi.encodePacked(
        //             "withdrawBP failed: last balance: ", Strings.toString(lastBalance),
        //             ", pre balance: ", Strings.toString(preBalance),
        //             ", amount: ", Strings.toString(amount)
        //         )
        //     );
        //     eventLoggerManager.recordEvent("withdrawBP", logMessage);
        // }

        // emit BPChanged(msg.sender, lastBalance);
    }
    
    // ch·ªâ cho ph√©p stockNode || rootNode || daoNode g·ªçi
    function withdrawBPToAnotherUser(uint256 amount, address user) external {
        require(amount > 0, "Amount must be greater than 0");
        
        require(rootNode == msg.sender || stockNode == msg.sender || daoNode == msg.sender, "Contracts not allowed");

        withdrawBPToUser(amount, user);
    }
    function withdrawBP(uint256 amount) external {
        require(amount > 0, "Amount must be greater than 0");
        
        /*

        - Ch·∫∑n smart contract g·ªçi ƒë·∫øn, nh∆∞ng v·∫´n cho ph√©p rootNode, stockNode, daoNode
        - Trong 3 smart contract, c·∫ßn th√™m ki·ªÉm tra msg.sender == tx.origin ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng l√† user g·ªçi t·ªõi tr·ª±c ti·∫øp smart contract
        
        modifier onlyEOA() {
            require(msg.sender == tx.origin, "Smart contracts not allowed");
            _;
        }
        
        */
        require(tx.origin == msg.sender || rootNode == msg.sender || stockNode == msg.sender || daoNode == msg.sender, "Contracts not allowed");
        withdrawBPToUser(amount, msg.sender);
    }

    /**
     * @dev C·∫≠p nh·∫≠t c·∫•p ƒë·ªô agent cho m·ªôt ng∆∞·ªùi d√πng
     * @param user ƒê·ªãa ch·ªâ ng∆∞·ªùi d√πng
     * @param level C·∫•p ƒë·ªô agent m·ªõi
     */
    function setAgentLevel(address user, uint256 level) public onlyOwner {
        require(nodes[user].parent != address(0), "User not exists"); // Ki·ªÉm tra ng∆∞·ªùi d√πng c√≥ t·ªìn t·∫°i kh√¥ng

        agentStorage.setAgentLevel(user, level);
    }

        /**
     * @dev X·ª≠ l√Ω h√†ng ƒë·ª£i (queue) c√°c th√†nh vi√™n m·ªõi v√† c√°c giao d·ªãch mua h√†ng
     * - X·ª≠ l√Ω l·∫ßn l∆∞·ª£t t·ª´ng th√†nh vi√™n trong `newMemberQueue` b·∫±ng `_processNewMember`
     * - X·ª≠ l√Ω t·ª´ng giao d·ªãch trong `salesQueue` b·∫±ng `_processPersonalSales`
     * - Sau khi x·ª≠ l√Ω xong, x√≥a to√†n b·ªô d·ªØ li·ªáu trong queue
     */
    function processQueue() internal {
        require(!isBatchProcessing, "Batch update is running"); // Ki·ªÉm tra h·ªá th·ªëng c√≥ ƒëang x·ª≠ l√Ω batch kh√¥ng

        // X·ª≠ l√Ω c√°c th√†nh vi√™n m·ªõi trong `newMemberQueue`
        for (uint256 i = 0; i < newMemberQueue.length; i++) {
            _processNewMember(
                newMemberQueue[i].newMember,
                newMemberQueue[i].parent,
                newMemberQueue[i].longtitude,
                newMemberQueue[i].lattitude,
                bytes32(0)
            );
        }
        delete newMemberQueue; // X√≥a d·ªØ li·ªáu queue sau khi x·ª≠ l√Ω

        // X·ª≠ l√Ω c√°c giao d·ªãch b√°n h√†ng c√° nh√¢n trong `salesQueue`
        for (uint256 i = 0; i < salesQueue.length; i++) {
            _processPersonalSales(salesQueue[i].user, salesQueue[i].bp, bytes32(0));
        }
        delete salesQueue; // X√≥a d·ªØ li·ªáu queue sau khi x·ª≠ l√Ω
    }

    /**
     * @dev Ghi nh·∫≠n giao d·ªãch b√°n h√†ng c√° nh√¢n
     * - N·∫øu h·ªá th·ªëng ƒëang batch, th√™m giao d·ªãch v√†o `salesQueue` ƒë·ªÉ x·ª≠ l√Ω sau
     * - N·∫øu kh√¥ng, x·ª≠ l√Ω ngay l·∫≠p t·ª©c b·∫±ng `processQueue` v√† `_processPersonalSales`
     * @param user ƒê·ªãa ch·ªâ th√†nh vi√™n th·ª±c hi·ªán giao d·ªãch
     * @param bp ƒêi·ªÉm BP c·ªßa giao d·ªãch
     */
    function recordPersonalSales(address user, uint256 bp, bytes32 utxoID) internal {
        require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng c√≥ ƒëang kh√≥a d·ªØ li·ªáu kh√¥ng
        if (isBatchProcessing) {
            salesQueue.push(SalesRecord(user, bp, utxoID)); // N·∫øu ƒëang batch, th√™m giao d·ªãch v√†o queue
            return;
        }

        processQueue(); // N·∫øu kh√¥ng batch, x·ª≠ l√Ω queue tr∆∞·ªõc
        _processPersonalSales(user, bp, utxoID); // X·ª≠ l√Ω giao d·ªãch ngay
    }


    // Ghi nh·∫≠n doanh s·ªë ph√°t sinh m·ªói gi·ªù
    function recordSales(address user, uint256 bp) internal {
        if (!hourlySales[user].exists) {
            hourlySales[user].exists = true;
        }
        hourlySales[user].totalBP += bp;
    }

    /**
     * @dev X·ª≠ l√Ω giao d·ªãch b√°n h√†ng c√° nh√¢n, c·∫≠p nh·∫≠t BP v√† tr·∫£ hoa h·ªìng
     * - T√≠nh to√°n % hoa h·ªìng d·ª±a tr√™n c·∫•p ƒë·ªô (Agent hay kh√¥ng)
     * - C·∫≠p nh·∫≠t tr·∫°ng th√°i active n·∫øu c·∫ßn
     * - Ph√¢n ph·ªëi th∆∞·ªüng showroom, DAO, stock
     * @param user ƒê·ªãa ch·ªâ th√†nh vi√™n th·ª±c hi·ªán giao d·ªãch
     * @param bp ƒêi·ªÉm BP c·ªßa giao d·ªãch
     */
    function _processPersonalSales(address user, uint256 bp, bytes32 utxoID) internal {

        // n·∫øu th√†nh vi√™n l√† VIP, th√¨ ghi nh·∫≠n doanh s·ªë cho parent
        if (vipNodes[user].parent != address(0)){
            user = vipNodes[user].parent;
        }


        nodeData[user].personalBP += bp; // C·∫≠p nh·∫≠t BP c√° nh√¢n
        productBPThisMonth[user] += bp; // C·∫≠p nh·∫≠t BP th√°ng n√†y

        uint256 commissionPercent = 0; // % hoa h·ªìng
        uint256 newBP = bp; // BP sau khi t√≠nh to√°n v·ªõi Agent

        // 
        // tr·∫£ hoa h·ªìng th·∫ø h·ªá 20% n·∫øu ko ph·∫£i agent
        // N·∫øu user l√† Agent, t√≠nh % theo c·∫•p ƒë·ªô Agent
        //
        uint256 stockNodeBonus = 0;
        if (agentStorage.getAgentLevel(user) > 0) {
            commissionPercent = agentStorage.getAgentCommission(user, RETAIL_COMMISSION_PERCENT); // L·∫•y % theo c·∫•p ƒë·ªô Agent
            newBP = (bp * AGENT_FW_PERMILLE) / 1000; // ƒêi·ªÅu ch·ªânh BP theo ph·∫ßn ngh√¨n

            // 27.5% = 100% hoa h·ªìng - 40% tr·∫£ cho agent c·∫•p 1 v√† 32.4% cho hoa h·ªìng c√°c t·∫ßng tr√™n
            stockNodeBonus = (1000 - 400 - 325) * bp / 1000;
        } else {
            commissionPercent = RETAIL_COMMISSION_PERCENT; // N·∫øu kh√¥ng ph·∫£i Agent, l·∫•y % b√°n l·∫ª
            stockNodeBonus = (bp * 32) / 100;
        }

        if (nodes[user].status != TreeLib.Status.Locked) {
          balancesManager.updateBalance(user, utxoID, (bp * commissionPercent) / 100, true);
        }

        // --- end


        bool wasActive = nodes[user].status == TreeLib.Status.Active; // Ki·ªÉm tra tr·∫°ng th√°i tr∆∞·ªõc khi c·∫≠p nh·∫≠t
        // updateActiveStatus(user); // C·∫≠p nh·∫≠t tr·∫°ng th√°i active n·∫øu c·∫ßn
        nodes.updateActiveStatus(nodeData, membershipSoldThisMonth, productBPThisMonth, newMembershipInTeamThisMonth, user);

        // N·∫øu tr∆∞·ªõc ƒë√≥ kh√¥ng active nh∆∞ng gi·ªù active, c·∫≠p nh·∫≠t cha Active
        if (!wasActive && nodes[user].status == TreeLib.Status.Active) {
            TreeLib.updateActiveParentMapping(nodes, activeParentMapping, user);
        }

        emit BPChanged(user, bp); // Ph√°t s·ª± ki·ªán thay ƒë·ªïi BP cho user

        // tr·∫£ hoa h·ªìng th·∫ø h·ªá 30% = 10 + 5 + 5 + 5 + 5
        nodes.distributeUnilevelBonus(activeParentMapping, balancesManager, user, newBP, utxoID); // Ph√¢n ph·ªëi th∆∞·ªüng Unilevel cho tuy·∫øn tr√™n

        recordSales(user, newBP);
        
        // hoa h·ªìng cho nationalBonusPool 2%
        uint256 nationalBonus = (newBP * NATIONAL_BONUS_POOL_PERCENT) / 100;
        balancesManager.addNationalBonusPool(nationalBonus, utxoID);
        

        // tr·∫£ hoa h·ªìng showroom 1%
        address showroom = memberInShowroom[user]; // L·∫•y showroom c·ªßa user
        if (showroom != address(0)) {

            uint256 comm = showroomManager.plusCommision(showroom, newBP);

            uint256 amountBP = (newBP * SHOWROOM_COMMISSION_PERCENT * comm) / 10000; // Tr·∫£ hoa h·ªìng cho showroom
            // balances[showroom] += amountBP;
            balancesManager.updateBalance(showroom, utxoID, amountBP, true);

        }
        // tr·∫£ hoa h·ªìng th·∫ø h·ªá 11% = 2 + 3 + 3 + 3 
        TreeLib.distributeGenerationBonus(nodes, generationRank, personalGroups, balancesManager, user, bp, utxoID);

        // hoa h·ªìng cho DAO 4%
        balancesManager.updateBalance(daoNode, utxoID, (newBP * DAO_COMMISSION_PERCENT) / 100, true);

        // hoa h·ªìng cho stock
        balancesManager.updateBalance(stockNode, utxoID, stockNodeBonus, true);


    }


    /**
     * @dev Th√™m m·ªôt VIP member v√†o h·ªá th·ªëng
     * @param newMember ƒê·ªãa ch·ªâ c·ªßa th√†nh vi√™n m·ªõi
     * @param parent ƒê·ªãa ch·ªâ cha c·ªßa th√†nh vi√™n
     */
    function addVIPMember(address newMember, address parent, bytes32 utxoID) external onlyEOA {
        require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng c√≥ ƒëang n√¢ng c·∫•p kh√¥ng
        require(nodes[newMember].parent == address(0), "User already exists"); // Ki·ªÉm tra user ƒë√£ t·ªìn t·∫°i ch∆∞a
        require(vipNodes[newMember].parent == address(0), "User already exists in VIP"); // Ki·ªÉm tra user ƒë√£ t·ªìn t·∫°i trong VIP ch∆∞a
        // require(nodes[parent].parent != address(0), "Parent does not exist"); // Ki·ªÉm tra cha c√≥ t·ªìn t·∫°i v√† ƒëang active kh√¥ng
        
        // b·ªè ƒëi·ªÅu ki√™n n√†y , ƒë·ªÉ khi parent v·ª´a m·ªõi ƒëƒÉng k√Ω v·∫´n c√≥ th·ªÉ cho user kh√°c ·ªü d∆∞·ªõi ƒë∆∞·ª£c
        // require(nodes[parent].status == TreeLib.Status.Active, "Parent is not active"); // Ki·ªÉm tra cha c√≥ ƒëang active kh√¥ng

        // nh·ªØng user mu·ªën ƒëƒÉng k√Ω d∆∞·ªõi address root th√¨ ph·∫£i do owner t·∫°o
        require(parent != rootNode || msg.sender == owner, "Parent not allow");
        // require(msg.value == MEMBERSHIP_FEE, "Incorrect fee"); // Ki·ªÉm tra ph√≠ membership

        TreeLib.checkTransferUSDT(usdtToken, utxoID, MEMBERSHIP_FEE);

        

        vipNodes[newMember] = VIPNode({ // T·∫°o m·ªôt node VIP m·ªõi
            parent: parent,
            membershipExpiry: block.timestamp + 365 days // H·∫øt h·∫°n sau 12 th√°ng
        });

        vipNodesList[parent].push(newMember); // Th√™m v√†o danh s√°ch VIP c·ªßa cha
        recordPersonalSales(newMember, MEMBERSHIP_BP, utxoID); // Ghi l·∫°i doanh s·ªë c√° nh√¢n c·ªßa th√†nh vi√™n m·ªõi
        // emit VIPAdded(newMember, parent); // Ph√°t s·ª± ki·ªán VIP m·ªõi ƒë∆∞·ª£c th√™m

        balancesManager.updateBalance(stockNode, utxoID, MEMBERSHIP_FEE / 1e6 - MEMBERSHIP_BP, true);

    }

    /**
     * @dev L·∫•y danh s√°ch c√°c th√†nh vi√™n VIP tr·ª±c thu·ªôc m·ªôt node
     * @param user ƒê·ªãa ch·ªâ c·ªßa node (cha)
     * @param startIndex V·ªã tr√≠ b·∫Øt ƒë·∫ßu trong danh s√°ch
     * @param pageSize S·ªë l∆∞·ª£ng VIP tr·∫£ v·ªÅ trong m·ªôt l·∫ßn
     * @return M·∫£ng ch·ª©a ƒë·ªãa ch·ªâ c√°c VIP tr·ª±c thu·ªôc
     */
    function getVIPMembers(address user, uint256 startIndex, uint256 pageSize) external onlyEOA view returns (address[] memory) {
        require(pageSize > 0 && pageSize <= 50, "pageSize must be between 1 and 50");

        uint256 totalChildCount = vipNodesList[user].length; // T·ªïng s·ªë VIP c·ªßa user
        if (startIndex >= totalChildCount) {
            return new address[](0); // v·ªÅ m·∫£ng r·ªóng n·∫øu startIndex v∆∞·ª£t qu√°
        }

        uint256 endIndex = startIndex + pageSize;
        if (endIndex > totalChildCount) {
            endIndex = totalChildCount; // ƒêi·ªÅu ch·ªânh endIndex n·∫øu v∆∞·ª£t qu√° t·ªïng
        }

        address[] memory paginatedChildren = new address[](endIndex - startIndex); // M·∫£ng k·∫øt qu·∫£
        uint256 resultIndex = 0;

        for (uint256 i = startIndex; i < endIndex; i++) {
            paginatedChildren[resultIndex] = vipNodesList[user][i]; // L·∫•y VIP t·ª´ danh s√°ch
            resultIndex++;
        }

        return paginatedChildren; // Tr·∫£ v·ªÅ danh s√°ch VIP ƒë√£ ph√¢n trang
    }

    /**
     * @dev Th√™m m·ªôt th√†nh vi√™n Promoter m·ªõi v√†o h·ªá th·ªëng
     * @param newMember ƒê·ªãa ch·ªâ th√†nh vi√™n m·ªõi
     * @param parent ƒê·ªãa ch·ªâ cha tr·ª±c ti·∫øp
     * @param longtitude Kinh ƒë·ªô v·ªã tr√≠ th√†nh vi√™n m·ªõi
     * @param lattitude Vƒ© ƒë·ªô v·ªã tr√≠ th√†nh vi√™n m·ªõi
     */
    function addPromoterMember(address newMember, address parent, uint256 longtitude, uint256 lattitude, bytes32 utxoID) external onlyEOA {
        require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng
        require(nodes[newMember].parent == address(0), "User already exists"); // Th√†nh vi√™n ƒë√£ t·ªìn t·∫°i
        require(vipNodes[newMember].parent == address(0), "User already exists in VIP"); // Th√†nh vi√™n ƒë√£ t·ªìn t·∫°i trong danh s√°ch VIP
        require(nodes[parent].parent != address(0), "Parent does not exist"); // Ki·ªÉm tra cha c√≥ t·ªìn t·∫°i v√† ƒëang active kh√¥ng

        // nh·ªØng user mu·ªën ƒëƒÉng k√Ω d∆∞·ªõi address root th√¨ ph·∫£i do owner t·∫°o
        require(parent != rootNode || msg.sender == owner, "Parent not allow");

        // require(msg.value == ACTIVATION_FEE + MEMBERSHIP_FEE, "Incorrect fee"); // Ki·ªÉm tra ph√≠ thanh to√°n ƒë·ªß kh√¥ng

        TreeLib.checkTransferUSDT(usdtToken, utxoID, ACTIVATION_FEE + MEMBERSHIP_FEE);

        // Ghi nh·∫≠n doanh s·ªë c√° nh√¢n khi th√™m th√†nh vi√™n m·ªõi
        recordPersonalSales(newMember, MEMBERSHIP_BP, utxoID);

        balancesManager.updateBalance(stockNode, utxoID, MEMBERSHIP_FEE / 1e6 - MEMBERSHIP_BP, true);

        if (isBatchProcessing) { 
            // N·∫øu h·ªá th·ªëng ƒëang ch·∫°y batch, th√™m th√†nh vi√™n v√†o queue ƒë·ªÉ x·ª≠ l√Ω sau
            newMemberQueue.push(NewMember(newMember, parent, longtitude, lattitude, utxoID));
            // emit PromoterAdded(newMember, parent); // Ph√°t s·ª± ki·ªán th√™m th√†nh vi√™n
            return;
        }

        // N·∫øu kh√¥ng trong batch, x·ª≠ l√Ω ngay l·∫≠p t·ª©c
        processQueue();
        _processNewMember(newMember, parent, longtitude, lattitude, utxoID); 
        // emit PromoterAdded(newMember, parent);
    }

    /**
     * @dev N√¢ng c·∫•p m·ªôt t√†i kho·∫£n t·ª´ VIP l√™n Promoter
     * @param user ƒê·ªãa ch·ªâ t√†i kho·∫£n VIP c·∫ßn n√¢ng c·∫•p
     * @param longtitude Kinh ƒë·ªô v·ªã tr√≠ c·ªßa th√†nh vi√™n
     * @param lattitude Vƒ© ƒë·ªô v·ªã tr√≠ c·ªßa th√†nh vi√™n
     */
    function upgradeToPromoter(address user, uint256 longtitude, uint256 lattitude, bytes32 utxoID) external payable onlyEOA {
        require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng c√≥ ƒëang n√¢ng c·∫•p kh√¥ng
        require(vipNodes[user].parent != address(0), "User not pending"); // Ki·ªÉm tra th√†nh vi√™n c√≥ trong danh s√°ch VIP kh√¥ng
        // require(msg.value == ACTIVATION_FEE, "Incorrect fee"); // Ki·ªÉm tra ph√≠ n√¢ng c·∫•p

        require(vipNodes[user].membershipExpiry >= block.timestamp, "Membership expired"); // Ki·ªÉm tra h·∫°n membership

        address parent = vipNodes[user].parent; // L·∫•y ƒë·ªãa ch·ªâ cha
        require(nodes[parent].parent != address(0), "Parent does not exist"); // Ki·ªÉm tra cha c√≥ t·ªìn t·∫°i v√† active kh√¥ng

        TreeLib.checkTransferUSDT(usdtToken, utxoID, ACTIVATION_FEE);


        // X√≥a th√†nh vi√™n kh·ªèi danh s√°ch VIP
        delete vipNodes[user]; 
        for (uint256 i = 0; i < vipNodesList[parent].length; i++) {
            if (vipNodesList[parent][i] == user) {
                vipNodesList[parent][i] = vipNodesList[parent][vipNodesList[parent].length - 1]; // Thay th·∫ø b·∫±ng ph·∫ßn t·ª≠ cu·ªëi c√πng
                vipNodesList[parent].pop(); // X√≥a ph·∫ßn t·ª≠ cu·ªëi
                break;
            }
        }

        if (isBatchProcessing) {
            // N·∫øu ƒëang batch, th√™m v√†o queue
            newMemberQueue.push(NewMember(user, parent, longtitude, lattitude, utxoID));
            return;
        }

        processQueue();
        _processNewMember(user, parent, longtitude, lattitude, utxoID); // Th√™m v√†o h·ªá th·ªëng
    }

    /**
     * @dev Gia h·∫°n Membership cho t√†i kho·∫£n Promoter
     * @param user ƒê·ªãa ch·ªâ th√†nh vi√™n c·∫ßn gia h·∫°n
     */
    function renewMembership(address user, bytes32 utxoID) external payable onlyEOA {
        require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng ƒëang c√≥ n√¢ng c·∫•p kh√¥ng

        if (vipNodes[user].parent == address(0)) {
          require(nodes[user].parent != address(0), "User does not exist"); // Ki·ªÉm tra t√†i kho·∫£n t·ªìn t·∫°i kh√¥ng
          require(block.timestamp <= nodeData[user].membershipExpiry, "Membership expired, cannot renew"); // Ki·ªÉm tra h·∫°n
        } else {
          require(nodes[user].parent == address(0), "User wrong structure");
        }
        // require(msg.value == MEMBERSHIP_FEE, "Incorrect fee"); // Ki·ªÉm tra ph√≠

        TreeLib.checkTransferUSDT(usdtToken, utxoID, MEMBERSHIP_FEE);


        nodeData[user].membershipExpiry += 365 days; // Gia h·∫°n th√™m 12 th√°ng
        recordPersonalSales(user, MEMBERSHIP_BP, utxoID); // Ghi nh·∫≠n doanh s·ªë c√° nh√¢n khi gia h·∫°n

        balancesManager.updateBalance(stockNode, utxoID, MEMBERSHIP_FEE / 1e6 - MEMBERSHIP_BP, true);

    }

    /**
     * @dev H√†m n·ªôi b·ªô ƒë·ªÉ x·ª≠ l√Ω th√™m th√†nh vi√™n m·ªõi v√†o h·ªá th·ªëng
     * @param newMember ƒê·ªãa ch·ªâ th√†nh vi√™n m·ªõi
     * @param parent ƒê·ªãa ch·ªâ cha tr·ª±c ti·∫øp
     * @param longtitude Kinh ƒë·ªô v·ªã tr√≠ th√†nh vi√™n m·ªõi
     * @param lattitude Vƒ© ƒë·ªô v·ªã tr√≠ th√†nh vi√™n m·ªõi
     */
    function _processNewMember(address newMember, address parent, uint256 longtitude, uint256 lattitude, bytes32 utxoID) internal {
        address showroom = showroomManager.findNearestShowroom(lattitude, longtitude); // T√¨m showroom g·∫ßn nh·∫•t


        // Kh·ªüi t·∫°o node m·ªõi trong h·ªá th·ªëng
        nodes[newMember] = TreeLib.NodeInfo({
            // hash: keccak256(abi.encode(nodes[parent].hash, keccak256(abi.encode(newMember)))),
            parent: parent,
            children: new address[](0),// Kh·ªüi t·∫°o m·∫£ng con r·ªóng
            rank: TreeLib.Rank.None,
            // showroom: showroom,
            status: TreeLib.Status.InActive
        });
        nodeData[newMember] = TreeLib.NodeData({
            processedChildren: 0,
            personalBP: 0,
            // personalGroupBP: 0,
            teamBP: 0,
            totalTeamBP: 0,
            membershipExpiry: block.timestamp + 365 days // H·∫°n 12 th√°ng
        });


        balancesManager.initUser(newMember, longtitude, lattitude);
        if (showroom != address(0)) {
            memberInShowroom[newMember] = showroom;
        }


        allNodes.push(newMember); // Th√™m node v√†o danh s√°ch t·∫•t c·∫£ nodes
        nodes[parent].children.push(newMember); // Th√™m v√†o danh s√°ch con c·ªßa cha
        membershipSoldThisMonth[parent] += 1; // C·∫≠p nh·∫≠t s·ªë membership b√°n ƒë∆∞·ª£c trong th√°ng

        // newMembershipInTeamThisMonth[parent] += 1;
        newMembershipInTeamHour[parent] += 1; // TƒÉng gi√° tr·ªã m·ªói gi·ªù


        // G·ªçi ViewTree ƒë·ªÉ l∆∞u quan h·ªá
        // ViewTree viewTree = ViewTree(viewTreeContract);
        // viewTree.addChild(parent, newMember);


        // if (!isInNewParents(parent)) {
        //     newParents.push(parent); // N·∫øu cha ch∆∞a c√≥ trong danh s√°ch newParents th√¨ th√™m v√†o
        // }

        activeParentMapping[newMember] = nodes[parent].status == TreeLib.Status.Active ? parent : TreeLib.findActiveParent(nodes, activeParentMapping, parent); // C·∫≠p nh·∫≠t cha Active

        leafNodes.push(newMember); // Th√™m v√†o danh s√°ch n√∫t l√°

        balancesManager.updateBalance(parent, utxoID, ACTIVATION_BP, true); // Tr·∫£ hoa h·ªìng k√≠ch ho·∫°t $10 cho parent

        if (showroom != address(0)) {
            uint256 comm = showroomManager.plusMember(showroom, 1);
            balancesManager.updateBalance(showroom, utxoID, (SHOWROOM_BONUS * comm) / 100, true); // Tr·∫£ hoa h·ªìng showroom

        }

        // balances[stockNode] += ACTIVATION_FEE - (SHOWROOM_BONUS + ACTIVATION_BP); // Tr·∫£ hoa h·ªìng cho stock
        balancesManager.updateBalance(stockNode, utxoID, ACTIVATION_FEE / 1e6 - (SHOWROOM_BONUS + ACTIVATION_BP), true);
    }

    function isVIP(address user) external view onlyEOA returns (bool) {
      return (nodes[user].parent != address(0) || vipNodes[user].parent != address(0));
    }

    function buyProduct(bytes32 orderID) external onlyEOA {
        require(isLockData == false, "System upgrade"); // Ki·ªÉm tra h·ªá th·ªëng c√≥ ƒëang n√¢ng c·∫•p kh√¥ng
        require(orderID != bytes32(0), "wrong order ID"); // Ki·ªÉm tra h·ªá th·ªëng c√≥ ƒëang n√¢ng c·∫•p kh√¥ng
        
        // g·ªçi qua smart contract ECOM ƒë·ªÉ l·∫•y th√¥ng tin t·ª´ orderID
        uint256 amount;
        uint256 bp;
        address parent;
        bool isVIPorPromoter = false;

        bytes32 utxoID;
        // g·ªçi qua smart contract

        // -end

        uint256 commission = amount / 1e6 - bp;
        require(commission > 0, "Wrong commission");

        require(parent != address(0), "Wrong amount");
        require(amount > 0, "Wrong amount");

        address user = msg.sender;

        // n·∫øu khi mua l√† VIP ho·∫∑c Promoter
        if (isVIPorPromoter) {
          require(nodes[user].parent != address(0) || vipNodes[user].parent != address(0), "User already exists in VIP or Promoter"); // Ki·ªÉm tra user ƒë√£ t·ªìn t·∫°i trong VIP ch∆∞a
        }

        if (nodes[user].parent == address(0)) {// n·∫øu user ko ph·∫£i l√† Promoter, th√¨ doanh s·ªë t√≠nh cho parent
          // t√≠nh doanh s·ªë cho parent
          user = parent;
          require(nodes[parent].parent != address(0), "Parent is not exists"); // Ki·ªÉm tra cha c√≥ ƒëang active kh√¥ng
        } else {
          require(nodes[user].status == TreeLib.Status.Active, "User is not active"); // Ki·ªÉm tra cha c√≥ ƒëang active kh√¥ng
          require(nodes[user].parent == parent, "Parent not match");

        }

        TreeLib.checkTransferUSDT(usdtToken, utxoID, amount);

        recordPersonalSales(user, bp, utxoID); // Ghi l·∫°i doanh s·ªë c√° nh√¢n c·ªßa th√†nh vi√™n m·ªõi

        balancesManager.updateBalance(rootNode, utxoID, commission, true);

    }

    // /**
    //  * @dev Ki·ªÉm tra xem m·ªôt cha c√≥ trong danh s√°ch newParents kh√¥ng
    //  * @param parent ƒê·ªãa ch·ªâ cha c·∫ßn ki·ªÉm tra
    //  * @return true n·∫øu c√≥, false n·∫øu kh√¥ng
    //  */
    // function isInNewParents(address parent) internal view returns (bool) {
    //     for (uint256 i = 0; i < newParents.length; i++) {
    //         if (newParents[i] == parent) return true;
    //     }
    //     return false;
    // }


    // Ki·ªÉm tra xem m·ªôt node c√≥ thu·ªôc nh√°nh c·ªßa node cha b·∫±ng Merkle Proof
    // proof s·∫Ω l√† hash ( address c·ªßa c√°c n√∫t trung gian )
    // function isDescendant(
    //     address _child,
    //     address _ancestor,
    //     bytes32[] memory proof
    // ) public view returns (bool) {
    //     bytes32 currentHash = nodes[_child].hash;

    //     for (uint256 i = 0; i < proof.length; i++) {
    //       // b·ªï sung ki·ªÉm tra ng·∫´u nhi√™n 1 node b·∫•t k·ª≥ ƒë·ªÉ ƒë·∫£m b·∫£o ko b·ªã l√†m gi·∫£ proof
    //         currentHash = keccak256(abi.encode(currentHash, proof[i]));
    //     }
    //     return currentHash == nodes[_ancestor].hash;

    // }


    function getPromoterInfo() external onlyEOA view returns (TreeLib.NodeInfo memory, TreeLib.NodeData memory) {
        // ch·ªâ cho ph√©p ViewTree g·ªçi
        // require(msg.sender == viewTreeContract, "Unauthorized caller");
        address user = msg.sender;
        require(nodes[user].parent != address(0), "User does not exist");
        return (nodes[user], nodeData[user]);
    }

    function getVIPInfo() external onlyEOA view returns (VIPNode memory) {
        // ch·ªâ cho ph√©p ViewTree g·ªçi
        // require(msg.sender == viewTreeContract, "Unauthorized caller");
        address user = msg.sender;
        require(vipNodes[user].parent != address(0), "User does not exist");
        return vipNodes[user];
    }

    /**
     * @dev L·∫•y danh s√°ch con tr·ª±c ti·∫øp c·ªßa m·ªôt user bao g·ªìm c·∫£ con ·∫£o, ph√¢n trang
     * @param user ƒê·ªãa ch·ªâ th√†nh vi√™n c·∫ßn l·∫•y danh s√°ch con
     * @param startIndex V·ªã tr√≠ b·∫Øt ƒë·∫ßu
     * @param pageSize S·ªë l∆∞·ª£ng tr·∫£ v·ªÅ
     * @return M·∫£ng ƒë·ªãa ch·ªâ con
     */
    function getChildren(address user, uint8 totalLevel, uint256 startIndex, uint256 pageSize) external onlyEOA returns (TreeLib.NodeInfo[] memory, TreeLib.NodeData[] memory) {
        // ch·ªâ cho ph√©p ViewTree g·ªçi
        // require(msg.sender == viewTreeContract, "Unauthorized caller");
        require(TreeLib.isDescendant(nodes, user, msg.sender, totalLevel, linkViewTree, allLinkViewTreeKeys), "Unauthorized caller");
        require(startIndex < nodes[user].children.length, "Invalid start index");

        uint256 totalChildren = nodes[user].children.length;

        if (startIndex >= totalChildren) return (new TreeLib.NodeInfo[](0), new TreeLib.NodeData[](0));// Tr·∫£ v·ªÅ m·∫£ng r·ªóng n·∫øu v∆∞·ª£t gi·ªõi h·∫°n


        uint256 actualPageSize = (startIndex + pageSize > totalChildren) ? (totalChildren - startIndex) : pageSize;

        TreeLib.NodeInfo[] memory childrenInfo = new TreeLib.NodeInfo[](actualPageSize);
        TreeLib.NodeData[] memory childrenData = new TreeLib.NodeData[](actualPageSize);

        for (uint256 i = 0; i < actualPageSize; i++) {
            address child = nodes[user].children[startIndex + i];
            childrenInfo[i] = nodes[child];
            childrenData[i] = nodeData[child];
        }

        return (childrenInfo, childrenData);
    }

        /**
     * @dev C·∫≠p nh·∫≠t danh s√°ch c√°c node l√° (leafNodes)
     * - Node l√° l√† node kh√¥ng c√≥ b·∫•t k·ª≥ node con n√†o.
     * - Qu√©t to√†n b·ªô danh s√°ch `leafNodes` hi·ªán t·∫°i.
     * - Lo·∫°i b·ªè nh·ªØng node kh√¥ng c√≤n l√† node l√° (t·ª©c l√† ƒë√£ c√≥ con).
     * - C·∫≠p nh·∫≠t l·∫°i danh s√°ch `leafNodes` ƒë·ªÉ ph·∫£n √°nh ch√≠nh x√°c tr·∫°ng th√°i hi·ªán t·∫°i.
     */
    function updateLeafNodes() internal {
        address[] memory updatedLeafNodes = new address[](leafNodes.length); // Kh·ªüi t·∫°o m·∫£ng t·∫°m ƒë·ªÉ l∆∞u node l√°
        uint256 count = 0; // Bi·∫øn ƒë·∫øm s·ªë l∆∞·ª£ng node l√°

        // Duy·ªát qua to√†n b·ªô node l√° hi·ªán t·∫°i
        for (uint256 i = 0; i < leafNodes.length; i++) {
            // Ki·ªÉm tra xem node n√†y c√≥ con kh√¥ng
            if (nodes[leafNodes[i]].children.length == 0) {
                updatedLeafNodes[count] = leafNodes[i]; // Gi·ªØ l·∫°i node l√† leaf
                count++;
            }
        }

        // C·∫≠p nh·∫≠t l·∫°i danh s√°ch `leafNodes` v·ªõi k√≠ch th∆∞·ªõc m·ªõi
        assembly {
            mstore(updatedLeafNodes, count) // Thi·∫øt l·∫≠p k√≠ch th∆∞·ªõc m·ªõi cho m·∫£ng
        }
        leafNodes = updatedLeafNodes; // G√°n l·∫°i `leafNodes` sau khi c·∫≠p nh·∫≠t
    }

    /**
     * @dev X·ª≠ l√Ω ƒë·ªá quy ƒë·ªÉ c·∫≠p nh·∫≠t TeamBP v√† tr·∫°ng th√°i Active cho c√°c c·∫•p cha.
     * - Khi m·ªôt node con ƒë∆∞·ª£c x·ª≠ l√Ω xong, tƒÉng b·ªô ƒë·∫øm processedChildren c·ªßa parent.
     * - N·∫øu parent c√≥ ph√°t sinh doanh s·ªë ho·∫∑c c√≥ node con ph√°t sinh doanh s·ªë,
     *   s·∫Ω g√°n c·ªù hasSales cho grandParent ƒë·ªÉ ƒë·∫£m b·∫£o doanh s·ªë ƒë∆∞·ª£c c·∫≠p nh·∫≠t xuy√™n su·ªët c√°c c·∫•p.
     * - N·∫øu grandParent ƒë√£ x·ª≠ l√Ω h·∫øt t·∫•t c·∫£ c√°c node con, th·ª±c hi·ªán updateTeamBP v√† g·ªçi ti·∫øp processParentRecursively.
     * - Ti·∫øp t·ª•c ƒë·ªá quy cho ƒë·∫øn khi ƒë·∫°t ƒë·∫øn rootNode.
     * @param parent ƒê·ªãa ch·ªâ c·ªßa node cha hi·ªán t·∫°i c·∫ßn x·ª≠ l√Ω.
     */
    function processParentRecursively(address parent) internal {
        address grandParent = nodes[parent].parent; // L·∫•y cha c·ªßa node hi·ªán t·∫°i

        if (grandParent == address(0)) return; // D·ª´ng n·∫øu ƒë√£ ƒë·∫øn root

        nodeData[grandParent].processedChildren += 1; // TƒÉng b·ªô ƒë·∫øm s·ªë con ƒë√£ x·ª≠ l√Ω

        if (
          hasSales[grandParent] != true // ki·ªÉm tra n·∫øu ch∆∞a ƒë∆∞·ª£c g√°n tr∆∞·ªõc
          && (hourlySales[parent].exists || hasSales[parent])
        ) { 
            hasSales[grandParent] = true; // G√°n c·ªù cho parent
        }
        delete hourlySales[parent];
        delete hasSales[parent];

        if (newMembershipInTeamHour[parent] > 0) { 
            newMembershipInTeamHour[grandParent] += newMembershipInTeamHour[parent]; // Ghi nh·∫≠n membership m·ªõi
            newMembershipInTeamThisMonth[grandParent] += newMembershipInTeamHour[parent]; // Ghi nh·∫≠n membership m·ªõi

            delete newMembershipInTeamHour[parent]; // Reset sau khi c·ªông
        }

        if (nodeData[grandParent].processedChildren == nodes[grandParent].children.length) {
            nodeData[grandParent].processedChildren = 0; // Reset b·ªô ƒë·∫øm
            
            if (hasSales[grandParent]) {
              nodeData.updateTeamBP(nodes, nationalDirectors, grandParent); // C·∫≠p nh·∫≠t TeamBP cho cha
            }

            processParentRecursively(grandParent); // ƒê·ªá quy l√™n c·∫•p cao h∆°n
        }
    }

    /**
     * @dev X·ª≠ l√Ω TeamBP v√† tr·∫°ng th√°i Active theo l√¥ (batch)
     * - Duy·ªát qua c√°c leafNodes theo batch ƒë·ªÉ tr√°nh h·∫øt gas.
     * - C·∫≠p nh·∫≠t TeamBP v√† Active Status cho t·ª´ng node l√°, sau ƒë√≥ ƒë·ªá quy l√™n c√°c c·∫•p cha.
     * - N·∫øu node c√≥ ph√°t sinh doanh s·ªë (n·∫±m trong hourlySales ho·∫∑c hasSales),
     *   s·∫Ω g√°n c·ªù hasSales cho parent ƒë·ªÉ ƒë·∫£m b·∫£o c·∫≠p nh·∫≠t TeamBP t·ª´ node l√° l√™n root.
     * - Khi m·ªôt parent ƒë√£ x·ª≠ l√Ω h·∫øt t·∫•t c·∫£ node con, th·ª±c hi·ªán updateTeamBP cho parent
     *   v√† g·ªçi ƒë·ªá quy processParentRecursively ƒë·ªÉ ti·∫øp t·ª•c c·∫≠p nh·∫≠t cho c√°c c·∫•p cha cao h∆°n.
     * @param startIndex V·ªã tr√≠ b·∫Øt ƒë·∫ßu trong danh s√°ch leafNodes.
     * @param batchSize S·ªë l∆∞·ª£ng leafNodes x·ª≠ l√Ω trong m·ªôt batch.
     * @return nextIndex V·ªã tr√≠ ti·∫øp theo ƒë·ªÉ ti·∫øp t·ª•c x·ª≠ l√Ω (ho·∫∑c 0 n·∫øu xong).
     */
    function processTeamBPAndActive(uint256 startIndex, uint256 batchSize) public onlyOwner  returns (uint256 nextIndex) {
        require(startIndex < leafNodes.length, "Invalid start index");
        require(batchSize > 0, "Batch size must be greater than 0");

        uint256 originalLeafCount = leafNodes.length; // L∆∞u s·ªë l∆∞·ª£ng node l√° ban ƒë·∫ßu

        // Gi·ªõi h·∫°n batchSize n·∫øu v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng c√≤n l·∫°i
        if (batchSize > originalLeafCount - startIndex) {
            batchSize = originalLeafCount - startIndex;
        }

        uint256 count = 0;

        while (count < batchSize && startIndex < originalLeafCount) {
            address user = leafNodes[startIndex];

            if (user == address(0) || user == rootNode) {
                return 0; // Tr·∫£ v·ªÅ 0 n·∫øu node kh√¥ng h·ª£p l·ªá
            }

            // updateActiveStatus(user); // C·∫≠p nh·∫≠t tr·∫°ng th√°i active cho node
            nodes.updateActiveStatus(nodeData, membershipSoldThisMonth, productBPThisMonth, newMembershipInTeamThisMonth, user);

            address parent = nodes[user].parent; // L·∫•y cha c·ªßa node
            if (parent != address(0)) {
                nodeData[parent].processedChildren += 1; // TƒÉng b·ªô ƒë·∫øm s·ªë con ƒë√£ x·ª≠ l√Ω

                if (
                  hasSales[parent] != true // ki·ªÉm tra n·∫øu ch∆∞a ƒë∆∞·ª£c g√°n tr∆∞·ªõc
                  && (hourlySales[user].exists || hasSales[user])) { 
                    hasSales[parent] = true; // G√°n c·ªù cho parent
                }
                
                delete hourlySales[user];
                delete hasSales[user];

                if (newMembershipInTeamHour[user] > 0) { 
                    newMembershipInTeamHour[parent] += newMembershipInTeamHour[user]; // Ghi nh·∫≠n membership m·ªõi
                    newMembershipInTeamThisMonth[parent] += newMembershipInTeamHour[user]; // Ghi nh·∫≠n membership m·ªõi
                    delete newMembershipInTeamHour[user]; // Reset sau khi c·ªông
                }

                // N·∫øu cha ƒë√£ x·ª≠ l√Ω h·∫øt c√°c node con, c·∫≠p nh·∫≠t TeamBP v√† g·ªçi ƒë·ªá quy
                if (nodeData[parent].processedChildren == nodes[parent].children.length) {
                    nodeData[parent].processedChildren = 0;

                    if (hasSales[parent]) {
                      nodeData.updateTeamBP(nodes, nationalDirectors, parent); // C·∫≠p nh·∫≠t TeamBP cho cha
                    }
                    processParentRecursively(parent); // G·ªçi ƒë·ªá quy l√™n c·∫•p cha
                }

                // N·∫øu cha ch∆∞a active, ki·ªÉm tra ƒëi·ªÅu ki·ªán v√† c·∫≠p nh·∫≠t n·∫øu c·∫ßn
                if (
                  hasSales[parent]
                  && nodes[parent].status != TreeLib.Status.Active
                  && TreeLib.checkActiveCondition(nodeData, parent)
                ) {
                    nodes[parent].status = TreeLib.Status.Active;
                    // updateActiveParentMapping(parent); // C·∫≠p nh·∫≠t cha Active
                    TreeLib.updateActiveParentMapping(nodes, activeParentMapping, parent); // C·∫≠p nh·∫≠t cha Active
                }
            }

            startIndex++; // Chuy·ªÉn sang leafNode ti·∫øp theo
            count++;
        }

        // Tr·∫£ v·ªÅ index ti·∫øp theo ƒë·ªÉ ti·∫øp t·ª•c ho·∫∑c 0 n·∫øu ƒë√£ x·ª≠ l√Ω xong
        return (startIndex < originalLeafCount) ? startIndex + 1 : 0;
    }

    // tr·∫£ th∆∞·ªüng cho hoa h·ªìng RANK BASES NATIONAL BONUS POOL (2% of BP)
    function distributeNationalBonus() external onlyOwner {
        TreeLib.distributeNationalBonus(balancesManager, nationalDirectors);
    }
    function getAddress() external view onlyOwner returns (address, address, address) {
         return ( daoNode, stockNode,rootNode);
    }


    /*
      D√πng b√™n ngo√†i g·ªçi v√†o h√†m m·ªói 24h
    */
    function dailyUpdateGenerationRank() external onlyOwner {
         nodes.updateGenerationRank(generationRank, personalGroups, rootNode, rootNode);
    }

    

        /**
     * @dev X·ª≠ l√Ω batch m·ªói gi·ªù ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i v√† t√≠nh to√°n TeamBP
     * - Kh√≥a d·ªØ li·ªáu trong qu√° tr√¨nh x·ª≠ l√Ω.
     * - C·∫≠p nh·∫≠t tr·∫°ng th√°i Active cho c√°c `newParents` (c√°c cha c√≥ th√†nh vi√™n m·ªõi).
     * - Ph√¢n ph·ªëi hoa h·ªìng Unilevel cho c√°c `newParents`.
     * - C·∫≠p nh·∫≠t danh s√°ch leafNodes.
     * - X·ª≠ l√Ω to√†n b·ªô TeamBP b·∫±ng c√°ch duy·ªát t·∫•t c·∫£ leafNodes theo batch.
     * - Sau khi ho√†n t·∫•t, m·ªü kh√≥a d·ªØ li·ªáu v√† x·ª≠ l√Ω c√°c giao d·ªãch ch·ªù.
     * - Reset danh s√°ch `newParents` ƒë·ªÉ chu·∫©n b·ªã cho batch ti·∫øp theo.
     */
    function hourlyBatchProcessing() external onlyOwner {
        require(isLockData == false, "System upgrade"); // Ki·ªÉm tra xem h·ªá th·ªëng c√≥ ƒëang kh√≥a d·ªØ li·ªáu kh√¥ng
        require(!isBatchProcessing, "Already processing"); // Ki·ªÉm tra n·∫øu ƒë√£ c√≥ m·ªôt batch ƒëang ch·∫°y
        isBatchProcessing = true; // B·∫Øt ƒë·∫ßu qu√° tr√¨nh batch

        // // C·∫≠p nh·∫≠t tr·∫°ng th√°i Active v√† ph√¢n ph·ªëi hoa h·ªìng cho cha m·ªõi
        // for (uint256 i = 0; i < newParents.length; i++) {
        //     address user = newParents[i];
        //     updateActiveStatus(user); // C·∫≠p nh·∫≠t tr·∫°ng th√°i Active c·ªßa user

        //     distributeUnilevelBonus(user, nodeData[newParents[i]].personalBP); // Ph√¢n ph·ªëi hoa h·ªìng Unilevel
        // }

        updateLeafNodes(); // C·∫≠p nh·∫≠t danh s√°ch c√°c leafNodes m·ªõi

        // X·ª≠ l√Ω to√†n b·ªô TeamBP b·∫±ng batch ƒë·ªÉ ti·∫øt ki·ªám gas
        uint256 batchSize = 30; // K√≠ch th∆∞·ªõc m·ªói batch
        uint256 startIndex = 0; // B·∫Øt ƒë·∫ßu t·ª´ leafNode ƒë·∫ßu ti√™n
        while (startIndex < leafNodes.length) { // Duy·ªát qua t·∫•t c·∫£ leafNodes
            uint256 nextIndex = processTeamBPAndActive(startIndex, batchSize); // X·ª≠ l√Ω batch
            if (nextIndex == 0) {
                break; // D·ª´ng n·∫øu kh√¥ng c√≤n leafNodes ƒë·ªÉ x·ª≠ l√Ω
            }
            startIndex = nextIndex; // Chuy·ªÉn sang batch ti·∫øp theo
        }

        isBatchProcessing = false; // K·∫øt th√∫c qu√° tr√¨nh batch
        processQueue(); // X·ª≠ l√Ω c√°c giao d·ªãch ch·ªù trong queue

        // delete newParents; // X√≥a danh s√°ch cha m·ªõi sau khi ƒë√£ x·ª≠ l√Ω
    }


    /**
     * @dev X·ª≠ l√Ω batch m·ªói th√°ng ƒë·ªÉ reset d·ªØ li·ªáu v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i Active
     * - Ch·ªâ ƒë∆∞·ª£c g·ªçi sau khi ƒë√£ ch·∫°y `hourlyBatchProcessing` ƒë·ªÉ ƒë·∫£m b·∫£o s·ªë li·ªáu ch√≠nh x√°c.
     * - Duy·ªát qua t·∫•t c·∫£ c√°c node trong h·ªá th·ªëng theo t·ª´ng batch.
     * - Ki·ªÉm tra ƒëi·ªÅu ki·ªán Active c·ªßa t·ª´ng user.
     * - N·∫øu kh√¥ng ƒë·∫°t ƒëi·ªÅu ki·ªán, chuy·ªÉn tr·∫°ng th√°i v·ªÅ InActive.
     * - Reset d·ªØ li·ªáu c·ªßa th√°ng: s·ªë membership b√°n v√† BP s·∫£n ph·∫©m.
     * @param startIndex V·ªã tr√≠ b·∫Øt ƒë·∫ßu trong danh s√°ch allNodes
     * @param batchSize S·ªë l∆∞·ª£ng node x·ª≠ l√Ω trong m·ªói batch
     */
    function resetMonthlyData(uint256 startIndex, uint256 batchSize) external onlyOwner {
        require(startIndex < allNodes.length, "Invalid start index"); // Ki·ªÉm tra v·ªã tr√≠ b·∫Øt ƒë·∫ßu h·ª£p l·ªá


        delete nationalDirectors;

        uint256 endIndex = startIndex + batchSize > allNodes.length ? allNodes.length : startIndex + batchSize; // X√°c ƒë·ªãnh v·ªã tr√≠ k·∫øt th√∫c

        for (uint256 i = startIndex; i < endIndex; i++) { // Duy·ªát qua c√°c node trong batch
            address user = allNodes[i];

            bool isActive = false; // Bi·∫øn ki·ªÉm tra tr·∫°ng th√°i Active
            // Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán ƒë·ªÉ Active
            if (membershipSoldThisMonth[user] >= 1
                || newMembershipInTeamThisMonth[user] >= 10
                || productBPThisMonth[user] >= 100) {
                isActive = true;
            }

            if (!isActive) { // N·∫øu kh√¥ng ƒë·∫°t ƒëi·ªÅu ki·ªán Active
                nodes[user].status = TreeLib.Status.InActive; // Chuy·ªÉn v·ªÅ InActive

                // updateRanks(user); // C·∫≠p nh·∫≠t l·∫°i Rank
                TreeLib.updateRanks(nodes, nodeData, nationalDirectors, user); // C·∫≠p nh·∫≠t l·∫°i Rank

            } else {
                // updateActiveParentMapping(user); // C·∫≠p nh·∫≠t l·∫°i cha Active
                TreeLib.updateActiveParentMapping(nodes, activeParentMapping, user);

            }

            // Reset d·ªØ li·ªáu th√°ng
            delete membershipSoldThisMonth[user];
            delete newMembershipInTeamThisMonth[user];
            delete productBPThisMonth[user];
        }

        
        for (uint256 i = 0; i < allLinkViewTreeKeys.length; i++) {
            delete linkViewTree[allLinkViewTreeKeys[i]];
        }
        
        delete allLinkViewTreeKeys;

    }

}
