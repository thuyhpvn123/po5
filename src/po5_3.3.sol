// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*

  Thuật toán:

  ### **📌 Giải pháp Smart Contract cho "Power of 5"**  
  Dưới đây là giải pháp để triển khai hệ thống **Power of 5 Compensation Plan** trên Blockchain, đảm bảo 7 phần thưởng hoạt động chính xác:

  ✅ Chi trả đúng Activation Fee ($10 cho upline)

  ✅ Tính toán chính xác hoa hồng bán lẻ (20% BP), 4% cho DAO, 1% cho showroom gần user nhất

  ✅ Áp dụng Unilevel Bonus (10%-5%-5%-5%-5%)

  ✅ Tính PGB (2%) cho tuyến dưới chưa đạt STL

  ✅ Tính GB (3%) cho tuyến dưới đã đạt STL (nếu đạt Director trở lên)

  ✅ Giới hạn tối đa 50% từ chân mạnh

  ✅ Tích hợp Agent Program & chia 32.5% TGBP vào Unilevel

  Bên cạnh đó:

  ✅ **Cập nhật trạng thái Active & TeamBP theo thứ tự chính xác**  

  ✅ **Batch processing mỗi giờ giúp cập nhật hệ thống chính xác & tiết kiệm gas**  

  📌 Quy trình:

  1. Bắt đầu từ các leafNodes (tuyến dưới cùng, không có con).

  2. Từng node cập nhật dữ liệu cho cha, cho đến khi đạt root.

  3. Mỗi node chỉ tính toán sau khi tất cả con đã được xử lý.

  4. Mỗi 24h, cập nhật `generationRank` từ root xuống lá cho hệ thống.

*/

// Import các hợp đồng ERC20 và Ownable từ OpenZeppelin để quản lý token và kiểm soát quyền
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";



/**
 * @notice Solidity library offering basic trigonometry functions where inputs and outputs are
 * integers. Inputs are specified in radians scaled by 1e18, and similarly outputs are scaled by 1e18.
 *
 * This implementation is based off the Solidity trigonometry library written by Lefteris Karapetsas
 * which can be found here: https://github.com/Sikorkaio/sikorka/blob/e75c91925c914beaedf4841c0336a806f2b5f66d/contracts/trigonometry.sol
 *
 * Compared to Lefteris' implementation, this version makes the following changes:
 *   - Uses a 32 bits instead of 16 bits for improved accuracy
 *   - Updated for Solidity 0.8.x
 *   - Various gas optimizations
 *   - Change inputs/outputs to standard trig format (scaled by 1e18) instead of requiring the
 *     integer format used by the algorithm
 *
 * Lefertis' implementation is based off Dave Dribin's trigint C library
 *     http://www.dribin.org/dave/trigint/
 *
 * Which in turn is based from a now deleted article which can be found in the Wayback Machine:
 *     http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html
 */
library Trigonometry {
  // Table index into the trigonometric table
  uint256 constant INDEX_WIDTH        = 8;
  // Interpolation between successive entries in the table
  uint256 constant INTERP_WIDTH       = 16;
  uint256 constant INDEX_OFFSET       = 28 - INDEX_WIDTH;
  uint256 constant INTERP_OFFSET      = INDEX_OFFSET - INTERP_WIDTH;
  uint32  constant ANGLES_IN_CYCLE    = 1073741824;
  uint32  constant QUADRANT_HIGH_MASK = 536870912;
  uint32  constant QUADRANT_LOW_MASK  = 268435456;
  uint256 constant SINE_TABLE_SIZE    = 256;

  // Pi as an 18 decimal value, which is plenty of accuracy: "For JPL's highest accuracy calculations, which are for
  // interplanetary navigation, we use 3.141592653589793: https://www.jpl.nasa.gov/edu/news/2016/3/16/how-many-decimals-of-pi-do-we-really-need/
  uint256 constant PI          = 3141592653589793238;
  uint256 constant TWO_PI      = 2 * PI;
  uint256 constant PI_OVER_TWO = PI / 2;

  // The constant sine lookup table was generated by generate_trigonometry.py. We must use a constant
  // bytes array because constant arrays are not supported in Solidity. Each entry in the lookup
  // table is 4 bytes. Since we're using 32-bit parameters for the lookup table, we get a table size
  // of 2^(32/4) + 1 = 257, where the first and last entries are equivalent (hence the table size of
  // 256 defined above)
  uint8   constant entry_bytes = 4; // each entry in the lookup table is 4 bytes
  uint256 constant entry_mask  = ((1 << 8*entry_bytes) - 1); // mask used to cast bytes32 -> lookup table entry
  bytes   constant sin_table   = hex"00_00_00_00_00_c9_0f_88_01_92_1d_20_02_5b_26_d7_03_24_2a_bf_03_ed_26_e6_04_b6_19_5d_05_7f_00_35_06_47_d9_7c_07_10_a3_45_07_d9_5b_9e_08_a2_00_9a_09_6a_90_49_0a_33_08_bc_0a_fb_68_05_0b_c3_ac_35_0c_8b_d3_5e_0d_53_db_92_0e_1b_c2_e4_0e_e3_87_66_0f_ab_27_2b_10_72_a0_48_11_39_f0_cf_12_01_16_d5_12_c8_10_6e_13_8e_db_b1_14_55_76_b1_15_1b_df_85_15_e2_14_44_16_a8_13_05_17_6d_d9_de_18_33_66_e8_18_f8_b8_3c_19_bd_cb_f3_1a_82_a0_25_1b_47_32_ef_1c_0b_82_6a_1c_cf_8c_b3_1d_93_4f_e5_1e_56_ca_1e_1f_19_f9_7b_1f_dc_dc_1b_20_9f_70_1c_21_61_b3_9f_22_23_a4_c5_22_e5_41_af_23_a6_88_7e_24_67_77_57_25_28_0c_5d_25_e8_45_b6_26_a8_21_85_27_67_9d_f4_28_26_b9_28_28_e5_71_4a_29_a3_c4_85_2a_61_b1_01_2b_1f_34_eb_2b_dc_4e_6f_2c_98_fb_ba_2d_55_3a_fb_2e_11_0a_62_2e_cc_68_1e_2f_87_52_62_30_41_c7_60_30_fb_c5_4d_31_b5_4a_5d_32_6e_54_c7_33_26_e2_c2_33_de_f2_87_34_96_82_4f_35_4d_90_56_36_04_1a_d9_36_ba_20_13_37_6f_9e_46_38_24_93_b0_38_d8_fe_93_39_8c_dd_32_3a_40_2d_d1_3a_f2_ee_b7_3b_a5_1e_29_3c_56_ba_70_3d_07_c1_d5_3d_b8_32_a5_3e_68_0b_2c_3f_17_49_b7_3f_c5_ec_97_40_73_f2_1d_41_21_58_9a_41_ce_1e_64_42_7a_41_d0_43_25_c1_35_43_d0_9a_ec_44_7a_cd_50_45_24_56_bc_45_cd_35_8f_46_75_68_27_47_1c_ec_e6_47_c3_c2_2e_48_69_e6_64_49_0f_57_ee_49_b4_15_33_4a_58_1c_9d_4a_fb_6c_97_4b_9e_03_8f_4c_3f_df_f3_4c_e1_00_34_4d_81_62_c3_4e_21_06_17_4e_bf_e8_a4_4f_5e_08_e2_4f_fb_65_4c_50_97_fc_5e_51_33_cc_94_51_ce_d4_6e_52_69_12_6e_53_02_85_17_53_9b_2a_ef_54_33_02_7d_54_ca_0a_4a_55_60_40_e2_55_f5_a4_d2_56_8a_34_a9_57_1d_ee_f9_57_b0_d2_55_58_42_dd_54_58_d4_0e_8c_59_64_64_97_59_f3_de_12_5a_82_79_99_5b_10_35_ce_5b_9d_11_53_5c_29_0a_cc_5c_b4_20_df_5d_3e_52_36_5d_c7_9d_7b_5e_50_01_5d_5e_d7_7c_89_5f_5e_0d_b2_5f_e3_b3_8d_60_68_6c_ce_60_ec_38_2f_61_6f_14_6b_61_f1_00_3e_62_71_fa_68_62_f2_01_ac_63_71_14_cc_63_ef_32_8f_64_6c_59_bf_64_e8_89_25_65_63_bf_91_65_dd_fb_d2_66_57_3c_bb_66_cf_81_1f_67_46_c7_d7_67_bd_0f_bc_68_32_57_aa_68_a6_9e_80_69_19_e3_1f_69_8c_24_6b_69_fd_61_4a_6a_6d_98_a3_6a_dc_c9_64_6b_4a_f2_78_6b_b8_12_d0_6c_24_29_5f_6c_8f_35_1b_6c_f9_34_fb_6d_62_27_f9_6d_ca_0d_14_6e_30_e3_49_6e_96_a9_9c_6e_fb_5f_11_6f_5f_02_b1_6f_c1_93_84_70_23_10_99_70_83_78_fe_70_e2_cb_c5_71_41_08_04_71_9e_2c_d1_71_fa_39_48_72_55_2c_84_72_af_05_a6_73_07_c3_cf_73_5f_66_25_73_b5_eb_d0_74_0b_53_fa_74_5f_9d_d0_74_b2_c8_83_75_04_d3_44_75_55_bd_4b_75_a5_85_ce_75_f4_2c_0a_76_41_af_3c_76_8e_0e_a5_76_d9_49_88_77_23_5f_2c_77_6c_4e_da_77_b4_17_df_77_fa_b9_88_78_40_33_28_78_84_84_13_78_c7_ab_a1_79_09_a9_2c_79_4a_7c_11_79_8a_23_b0_79_c8_9f_6d_7a_05_ee_ac_7a_42_10_d8_7a_7d_05_5a_7a_b6_cb_a3_7a_ef_63_23_7b_26_cb_4e_7b_5d_03_9d_7b_92_0b_88_7b_c5_e2_8f_7b_f8_88_2f_7c_29_fb_ed_7c_5a_3d_4f_7c_89_4b_dd_7c_b7_27_23_7c_e3_ce_b1_7d_0f_42_17_7d_39_80_eb_7d_62_8a_c5_7d_8a_5f_3f_7d_b0_fd_f7_7d_d6_66_8e_7d_fa_98_a7_7e_1d_93_e9_7e_3f_57_fe_7e_5f_e4_92_7e_7f_39_56_7e_9d_55_fb_7e_ba_3a_38_7e_d5_e5_c5_7e_f0_58_5f_7f_09_91_c3_7f_21_91_b3_7f_38_57_f5_7f_4d_e4_50_7f_62_36_8e_7f_75_4e_7f_7f_87_2b_f2_7f_97_ce_bc_7f_a7_36_b3_7f_b5_63_b2_7f_c2_55_95_7f_ce_0c_3d_7f_d8_87_8d_7f_e1_c7_6a_7f_e9_cb_bf_7f_f0_94_77_7f_f6_21_81_7f_fa_72_d0_7f_fd_88_59_7f_ff_62_15_7f_ff_ff_ff";

  /**
   * @notice Return the sine of a value, specified in radians scaled by 1e18
   * @dev This algorithm for converting sine only uses integer values, and it works by dividing the
   * circle into 30 bit angles, i.e. there are 1,073,741,824 (2^30) angle units, instead of the
   * standard 360 degrees (2pi radians). From there, we get an output in range -2,147,483,647 to
   * 2,147,483,647, (which is the max value of an int32) which is then converted back to the standard
   * range of -1 to 1, again scaled by 1e18
   * @param _angle Angle to convert
   * @return Result scaled by 1e18
   */
  function sin(uint256 _angle) internal pure returns (int256) {
    unchecked {
      // Convert angle from from arbitrary radian value (range of 0 to 2pi) to the algorithm's range
      // of 0 to 1,073,741,824
      _angle = ANGLES_IN_CYCLE * (_angle % TWO_PI) / TWO_PI;

      // Apply a mask on an integer to extract a certain number of bits, where angle is the integer
      // whose bits we want to get, the width is the width of the bits (in bits) we want to extract,
      // and the offset is the offset of the bits (in bits) we want to extract. The result is an
      // integer containing _width bits of _value starting at the offset bit
      uint256 interp = (_angle >> INTERP_OFFSET) & ((1 << INTERP_WIDTH) - 1);
      uint256 index  = (_angle >> INDEX_OFFSET)  & ((1 << INDEX_WIDTH)  - 1);

      // The lookup table only contains data for one quadrant (since sin is symmetric around both
      // axes), so here we figure out which quadrant we're in, then we lookup the values in the
      // table then modify values accordingly
      bool is_odd_quadrant      = (_angle & QUADRANT_LOW_MASK)  == 0;
      bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;

      if (!is_odd_quadrant) {
        index = SINE_TABLE_SIZE - 1 - index;
      }

      bytes memory table = sin_table;
      // We are looking for two consecutive indices in our lookup table
      // Since EVM is left aligned, to read n bytes of data from idx i, we must read from `i * data_len` + `n`
      // therefore, to read two entries of size entry_bytes `index * entry_bytes` + `entry_bytes * 2`
      uint256 offset1_2 = (index + 2) * entry_bytes;

      // This following snippet will function for any entry_bytes <= 15
      uint256 x1_2; assembly {
        // mload will grab one word worth of bytes (32), as that is the minimum size in EVM
        x1_2 := mload(add(table, offset1_2))
      }

      // We now read the last two numbers of size entry_bytes from x1_2
      // in example: entry_bytes = 4; x1_2 = 0x00...12345678abcdefgh
      // therefore: entry_mask = 0xFFFFFFFF

      // 0x00...12345678abcdefgh >> 8*4 = 0x00...12345678
      // 0x00...12345678 & 0xFFFFFFFF = 0x12345678
      uint256 x1 = x1_2 >> 8*entry_bytes & entry_mask;
      // 0x00...12345678abcdefgh & 0xFFFFFFFF = 0xabcdefgh
      uint256 x2 = x1_2 & entry_mask;

      // Approximate angle by interpolating in the table, accounting for the quadrant
      uint256 approximation = ((x2 - x1) * interp) >> INTERP_WIDTH;
      int256 sine = is_odd_quadrant ? int256(x1) + int256(approximation) : int256(x2) - int256(approximation);
      if (is_negative_quadrant) {
        sine *= -1;
      }

      // Bring result from the range of -2,147,483,647 through 2,147,483,647 to -1e18 through 1e18.
      // This can never overflow because sine is bounded by the above values
      return sine * 1e18 / 2_147_483_647;
    }
  }

  /**
   * @notice Return the cosine of a value, specified in radians scaled by 1e18
   * @dev This is identical to the sin() method, and just computes the value by delegating to the
   * sin() method using the identity cos(x) = sin(x + pi/2)
   * @dev Overflow when `angle + PI_OVER_TWO > type(uint256).max` is ok, results are still accurate
   * @param _angle Angle to convert
   * @return Result scaled by 1e18
   */
  function cos(uint256 _angle) internal pure returns (int256) {
    unchecked {
      return sin(_angle + PI_OVER_TWO);
    }
  }
}


contract EventLogger {
    struct LogEntry {
        address sender;
        string eventType;  // Loại sự kiện (VD: "Deposit", "Withdraw", "Trade", "UpdateStatus")
        string details;    // Mô tả chi tiết sự kiện (VD: "User deposited 100 USDT")
        uint256 timestamp; // Thời gian xảy ra sự kiện
    }

    mapping(uint256 => LogEntry) public logs;
    uint256 public logCount;
    address public owner;

    // Sự kiện khi có log mới hoặc log bị xóa
    event LogEvent(uint256 indexed logId, address indexed sender, string eventType, string details, uint256 timestamp);
    event LogDeleted(uint256 indexed logId);
    event LogsClearedBefore(uint256 timestamp);
    event LogsClearedUpTo(uint256 upToId);
    event LogsCleared();

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can perform this action");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    // Ghi lại một log event quan trọng
    function recordEvent(string memory eventType, string memory details) external {
        logCount++;
        logs[logCount] = LogEntry(msg.sender, eventType, details, block.timestamp);
        emit LogEvent(logCount, msg.sender, eventType, details, block.timestamp);
    }

    // Xóa một event theo ID (chỉ owner mới có thể xóa)
    function deleteEvent(uint256 logId) external onlyOwner {
        require(logs[logId].timestamp != 0, "Log does not exist");
        delete logs[logId];
        emit LogDeleted(logId);
    }

    // Xóa tất cả logs có timestamp **trước** thời điểm `beforeTimestamp`
    function clearLogsBefore(uint256 beforeTimestamp) external onlyOwner {
        require(beforeTimestamp > 0 && beforeTimestamp <= block.timestamp, "Invalid timestamp");

        uint256 clearedLogs = 0;

        for (uint256 i = 1; i <= logCount; i++) {
            if (logs[i].timestamp > 0 && logs[i].timestamp < beforeTimestamp) {
                delete logs[i];
                clearedLogs++;
            }
        }

        emit LogsClearedBefore(beforeTimestamp);
    }

    // 🆕 Xóa tất cả logs có ID **≤ upToId**
    function clearLogsUpTo(uint256 upToId) external onlyOwner {
        require(upToId > 0 && upToId <= logCount, "Invalid ID range");

        uint256 clearedLogs = 0;

        for (uint256 i = 1; i <= upToId; i++) {
            if (logs[i].timestamp > 0) {
                delete logs[i];
                clearedLogs++;
            }
        }

        emit LogsClearedUpTo(upToId);
    }

    // Xóa toàn bộ logs (chỉ owner có thể thực hiện)
    function clearLogs() external onlyOwner {
        for (uint256 i = 1; i <= logCount; i++) {
            delete logs[i];
        }
        logCount = 0;
        emit LogsCleared();
    }

    // Lấy thông tin một log dựa trên ID
    function getLog(uint256 logId) external onlyOwner view returns (address sender, string memory eventType, string memory details, uint256 timestamp) {
        LogEntry memory log = logs[logId];
        require(log.timestamp != 0, "Log does not exist");
        return (log.sender, log.eventType, log.details, log.timestamp);
    }

    // Lấy tổng số log đã ghi lại
    function getTotalLogs() external onlyOwner view returns (uint256) {
        return logCount;
    }
}

interface ITreeCommission {
    /**
     * @dev Rút một lượng BP từ tài khoản người dùng.
     * @param amount Số lượng BP cần rút.
     */
    function withdrawBP(uint256 amount) external;
    function withdrawBPToAnotherUser(uint256 amount, address user) external;
}

// BalancesManager: Quản lý số dư, giao dịch, rút tiền.
contract BalancesManager is Ownable {

    // ultraUTXO
    
    struct BPultraUTXO {
        uint256 BP;
        uint256 createTime;
        uint256 activeTime;
        uint256 expiredTime;
        bool isDeny;
    }


    mapping(bytes32 => address[]) public utxoToUsers;
    mapping(address => mapping(bytes32 => BPultraUTXO)) public userUltraBP;
    bytes32[] public allUltraUTXO; // ✅ Danh sách toàn bộ UTXO


    mapping(address => uint256) public balances;


    struct NodeExtra {
        bytes32 refCode;
        string phoneNumber;
        string nickName;
        uint256 longtitude;
        uint256 lattitude;
    }

    mapping(address => NodeExtra) public nodeExtras;

    mapping(bytes32 => address) public allUserRefCodes;


    address public treeCommissionContract;


    uint256 internal nationalBonusPool;
    mapping(bytes32 => uint256) internal pendingNationalBonusPool; // Lưu BP đang chờ duyệt


    modifier onlyTreeCommission() {
        require(msg.sender == treeCommissionContract, "Unauthorized");
        _;
    }

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }

    constructor() Ownable(msg.sender) {}

    function setTreeCommissionAddress(address _treeCommissionAddress) external onlyOwner {
        treeCommissionContract = _treeCommissionAddress;
    }

    function isValidUTXO(bytes32 utxoID) internal pure returns (bool) {
        return utxoID != bytes32(0);
    }

    // ultra utxo

        // BP Ultra UTXO

    function createUltraUTXO(
        address user,
        bytes32 utxoID,
        uint256 amount
    ) internal {
        require(userUltraBP[user][utxoID].BP == 0, "UTXO already exists");

        uint256 createTime = block.timestamp;
        uint256 activeTime = createTime + 60 days;
        uint256 expiredTime = createTime + 180 days;

        userUltraBP[user][utxoID] = BPultraUTXO(amount, createTime, activeTime, expiredTime, false);
        utxoToUsers[utxoID].push(user);
        allUltraUTXO.push(utxoID); // ✅ Lưu vào danh sách toàn cục
    }

    function cancelUltraUTXO(
        bytes32 utxoID
    ) internal {
        require(utxoToUsers[utxoID].length > 0, "UTXO does not exist");

        for (uint256 i = 0; i < utxoToUsers[utxoID].length; i++) {
            address user = utxoToUsers[utxoID][i];

            if (userUltraBP[user][utxoID].BP > 0) {
                userUltraBP[user][utxoID].isDeny = true;
            }
        }
    }

    function withdrawUltraBP(
        address user,
        bytes32 utxoID
    ) internal {
        BPultraUTXO storage ultra = userUltraBP[user][utxoID];

        require(ultra.BP > 0, "No UltraBP available");
        require(!ultra.isDeny, "UTXO has been canceled");
        require(block.timestamp >= ultra.activeTime, "UltraBP is not yet withdrawable");
        require(block.timestamp <= ultra.expiredTime, "UltraBP has expired");

        uint256 amount = ultra.BP;
        require(amount > 0, "withdraw: Wrong amount");

        delete userUltraBP[user][utxoID];

        // gọi đến SM ultraUTXO

        // usdtToken.transfer(user, amount);
    }

    function getUltraBPInfo(address user, bytes32 utxoID)
        external
        view
        returns (uint256 BP, uint256 createTime, uint256 activeTime, uint256 expiredTime, bool isDeny)
    {
        BPultraUTXO memory ultra = userUltraBP[user][utxoID];
        return (ultra.BP, ultra.createTime, ultra.activeTime, ultra.expiredTime, ultra.isDeny);
    }

    function getAllUltraUTXOs() external view returns (bytes32[] memory) {
        return allUltraUTXO;
    }

    function getUserUltraUTXOs(address user) external view returns (bytes32[] memory) {
        bytes32[] memory userUTXOs = new bytes32[](allUltraUTXO.length);
        uint256 count = 0;

        for (uint256 i = 0; i < allUltraUTXO.length; i++) {
            if (userUltraBP[user][allUltraUTXO[i]].BP > 0) {
                userUTXOs[count] = allUltraUTXO[i];
                count++;
            }
        }

        bytes32[] memory trimmed = new bytes32[](count);
        for (uint256 i = 0; i < count; i++) {
            trimmed[i] = userUTXOs[i];
        }

        return trimmed;
    }


    function updateBalance(address user, bytes32 utxoID, uint256 amount, bool isAdd) external onlyTreeCommission {
        require(amount > 0, "update balance: Wrong amount");
        if (isAdd) {
            if (isValidUTXO(utxoID)) {
              balances[user] += amount;
            } else {
              createUltraUTXO(user, utxoID, amount);
            }
        } else {
            require(balances[user] >= amount, "Insufficient balance");
            balances[user] -= amount;
        }
    }

    function batchUpdateBalances(bytes32 utxoID, address[] calldata users, uint256[] calldata amounts, bool isAdd) external onlyTreeCommission {
        require(users.length == amounts.length, "Array lengths mismatch");
        for (uint256 i = 0; i < users.length; i++) {
            require(amounts[i] > 0, "update balance: Wrong amount");
            if (isAdd) {
                if (isValidUTXO(utxoID)) {
                  balances[users[i]] += amounts[i];
                } else {
                  createUltraUTXO(users[i], utxoID, amounts[i]);
                }
            } else {
                require(balances[users[i]] >= amounts[i], "Insufficient balance for user");
                balances[users[i]] -= amounts[i];
            }
        }
    }

    function getBalance(address user) external view returns (uint256) {
        return balances[user];
    }

    function withdrawBP(address user, uint256 amount) external onlyTreeCommission returns (bool) {
        if(amount <= 0) {
          return false;
        }
        if(balances[user] < amount) {
          return false;
        }

        balances[msg.sender] -= amount;

        return true;
    }

    function getRefCode() external view onlyEOA returns (bytes32) {
        // require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không

        return nodeExtras[msg.sender].refCode;
    }


    function getRefCodeToUser(bytes32 refCode) external view onlyEOA returns (address) {
        // require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không

        return allUserRefCodes[refCode];
    }


    function setRefCodeToUser(bytes32 oldRefCode, bytes32 newRefCode) external onlyEOA  {
        // require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không
        require(newRefCode != bytes32(0), "refCode not allowed");
        require( allUserRefCodes[oldRefCode] == msg.sender , "ref code not exists" );
        require( nodeExtras[msg.sender].refCode == oldRefCode , "ref code not exists in user" );

        require( allUserRefCodes[oldRefCode] == allUserRefCodes[newRefCode] , "ref code not match" );
        
        require( allUserRefCodes[newRefCode] != address(0) , "ref code exists in another user" );
        
        delete allUserRefCodes[oldRefCode];
        allUserRefCodes[newRefCode] = msg.sender;

        nodeExtras[msg.sender].refCode = newRefCode;
    }

    function setPhoneNumber(string calldata phoneNumber) external onlyEOA {
        // require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không

        require(bytes(phoneNumber).length > 0, "Phone number not allowed"); // Kiểm tra phone number không rỗng

        // require(nodes[msg.sender].parent != address(0), "User does not exist"); // Kiểm tra tài khoản tồn tại không
        // require(block.timestamp <= nodeData[msg.sender].membershipExpiry, "Membership expired, cannot renew"); // Kiểm tra hạn

        nodeExtras[msg.sender].phoneNumber = phoneNumber;
    }

    function setNickName(string calldata nickName) external onlyEOA {
        // require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không

        require(bytes(nickName).length > 0, "nickName not allow"); // Kiểm tra hệ thống đang có nâng cấp không

        // require(nodes[msg.sender].parent != address(0), "User does not exist"); // Kiểm tra tài khoản tồn tại không
        // require(block.timestamp <= nodeData[msg.sender].membershipExpiry, "Membership expired, cannot renew"); // Kiểm tra hạn

        nodeExtras[msg.sender].nickName = nickName;
    }

    function initUser(address user, uint256 longtitude, uint256 lattitude) external onlyTreeCommission {
        // require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không

        require(longtitude > 0, "longtitude not allow");
        require(lattitude > 0, "longtitude not allow");

        // require(nodes[msg.sender].parent != address(0), "User does not exist"); // Kiểm tra tài khoản tồn tại không
        // require(block.timestamp <= nodeData[msg.sender].membershipExpiry, "Membership expired, cannot renew"); // Kiểm tra hạn


        bytes32 refCode = keccak256(abi.encodePacked(user));

        require( allUserRefCodes[refCode] != address(0) , "ref code exists in another user" );
        
        allUserRefCodes[refCode] = user;

        nodeExtras[user] = NodeExtra({
            refCode: refCode,
            longtitude: longtitude,
            lattitude: lattitude,
            phoneNumber: "",
            nickName: ""
        });
    }

    // cộng balance cho bonus
    function addNationalBonusPool(uint256 amount, bytes32 utxoID) external {
      if (isValidUTXO(utxoID)) {
        pendingNationalBonusPool[utxoID] += amount;
      } else {
        nationalBonusPool += amount;
      }
    }
    function getNationalBonusPool() external view returns (uint256) {
      return nationalBonusPool;
    }
    function getPendingNationalBonusPool(bytes32 utxoID) external view returns (uint256) {
      return pendingNationalBonusPool[utxoID];
    }
    function resetNationalBonusPool(uint256 currentAmount) external {
      require(nationalBonusPool == currentAmount, "not match");
      nationalBonusPool = 0;
    }

    

    function confirmUTXO(bytes32 utxoID) external onlyOwner {
        require(pendingNationalBonusPool[utxoID] > 0, "not exists");
        nationalBonusPool += pendingNationalBonusPool[utxoID];
        delete pendingNationalBonusPool[utxoID]; // Xóa dữ liệu sau khi chuyển vào pool chính
    }
}


/**
 * @title DAO Voting Contract
 * @dev Quản lý biểu quyết chi tiêu. Yêu cầu 2/3 phiếu chấp thuận.
 */
contract ProposalVote {
    struct Proposal {
        address payable recipient; 
        uint256 amount;            
        string reason;             
        uint256 approvals;         
        uint256 rejections;        
        bool executed;             
    }

    struct MembershipProposal {
        address member;
        uint256 approvals;
        uint256 rejections;
        bool executed;
    }

    address[] public members; 
    mapping(address => bool) public isMember; 
    mapping(uint256 => Proposal) public proposals; 
    mapping(uint256 => MembershipProposal) public membershipProposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted;
    mapping(uint256 => mapping(address => bool)) public hasVotedMembership;
    
    uint256 public proposalCount;
    uint256 public membershipProposalCount;

    uint256 public approvalPercentage = 70;

    BalancesManager public balancesManager;
    address public treeCommissionContract;

    modifier onlyMember() {
        require(isMember[msg.sender], "Not a DAO member");
        _;
    }

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }
        
    constructor(address[] memory _initialMembers, address _balancesAddress) {
        require(_initialMembers.length >= 3, "Must have at least 3 members");
        for (uint i = 0; i < _initialMembers.length; i++) {
            isMember[_initialMembers[i]] = true;
            members.push(_initialMembers[i]);
        }

        balancesManager = BalancesManager(_balancesAddress);
        treeCommissionContract = msg.sender;
    }

    /**
     * @dev Yêu cầu thêm một thành viên mới thông qua biểu quyết
     * @param _newMember Địa chỉ của thành viên mới
     */
    function proposeAddMember(address _newMember) external onlyEOA onlyMember {
        require(!isMember[_newMember], "Already a member");

        membershipProposals[membershipProposalCount] = MembershipProposal({
            member: _newMember,
            approvals: 0,
            rejections: 0,
            executed: false
        });

        emit MemberProposalCreated(membershipProposalCount, _newMember);
        membershipProposalCount++;
    }

    /**
     * @dev Biểu quyết thêm thành viên mới
     * @param _proposalId ID của đề xuất
     * @param _approve Đồng ý hay từ chối (true = đồng ý, false = từ chối)
     */
    function voteToAddMember(uint256 _proposalId, bool _approve) external onlyEOA onlyMember {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(!proposal.executed, "Proposal already executed");
        require(!hasVotedMembership[_proposalId][msg.sender], "Already voted");

        hasVotedMembership[_proposalId][msg.sender] = true;

        if (_approve) {
            proposal.approvals++;
        } else {
            proposal.rejections++;
        }

        emit VotedMembership(_proposalId, msg.sender, _approve);

        if (proposal.approvals >= getApprovalThreshold()) {
            executeAddMember(_proposalId);
        }
    }

    /**
     * @dev Thực thi thêm thành viên mới nếu đủ phiếu
     */
    function executeAddMember(uint256 _proposalId) internal {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(proposal.approvals >= getApprovalThreshold(), "Not enough approvals");
        require(!proposal.executed, "Proposal already executed");

        proposal.executed = true;
        isMember[proposal.member] = true;
        members.push(proposal.member);

        emit MemberAdded(proposal.member);
    }

    /**
     * @dev Yêu cầu loại bỏ một thành viên thông qua biểu quyết
     * @param _member Địa chỉ của thành viên bị loại bỏ
     */
    function proposeRemoveMember(address _member) external onlyEOA onlyMember {
        require(isMember[_member], "Not a member");

        membershipProposals[membershipProposalCount] = MembershipProposal({
            member: _member,
            approvals: 0,
            rejections: 0,
            executed: false
        });

        emit MemberProposalCreated(membershipProposalCount, _member);
        membershipProposalCount++;
    }

    /**
     * @dev Biểu quyết loại bỏ thành viên
     * @param _proposalId ID của đề xuất
     * @param _approve Đồng ý hay từ chối (true = đồng ý, false = từ chối)
     */
    function voteToRemoveMember(uint256 _proposalId, bool _approve) external onlyEOA onlyMember {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(!proposal.executed, "Proposal already executed");
        require(!hasVotedMembership[_proposalId][msg.sender], "Already voted");

        hasVotedMembership[_proposalId][msg.sender] = true;

        if (_approve) {
            proposal.approvals++;
        } else {
            proposal.rejections++;
        }

        emit VotedMembership(_proposalId, msg.sender, _approve);

        if (proposal.approvals >= getApprovalThreshold()) {
            executeRemoveMember(_proposalId);
        }
    }

    /**
     * @dev Thực thi loại bỏ thành viên nếu đủ phiếu
     */
    function executeRemoveMember(uint256 _proposalId) internal {
        MembershipProposal storage proposal = membershipProposals[_proposalId];

        require(proposal.approvals >= getApprovalThreshold(), "Not enough approvals");
        require(!proposal.executed, "Proposal already executed");

        proposal.executed = true;
        isMember[proposal.member] = false;

        for (uint i = 0; i < members.length; i++) {
            if (members[i] == proposal.member) {
                members[i] = members[members.length - 1];
                members.pop();
                break;
            }
        }

        emit MemberRemoved(proposal.member);
    }

    /**
     * @dev Tính số phiếu cần thiết để phê duyệt đề xuất
     */
    function getApprovalThreshold() public view returns (uint256) {
        return (members.length * approvalPercentage) / 100;
    }

    event MemberProposalCreated(uint256 indexed proposalId, address indexed member);
    event MemberAdded(address indexed newMember);
    event MemberRemoved(address indexed removedMember);
    event VotedMembership(uint256 indexed proposalId, address indexed voter, bool approve);

    /**
     * @dev Tạo một đề xuất chi tiêu mới
     * @param _recipient Địa chỉ ví nhận tiền
     * @param _amount Số tiền muốn chi
     * @param _reason Lý do chi tiêu
     */
    function createProposal(address payable _recipient, uint256 _amount, string memory _reason) 
        external onlyEOA onlyMember 
    {
        proposals[proposalCount] = Proposal({
            recipient: _recipient,
            amount: _amount,
            reason: _reason,
            approvals: 0,
            rejections: 0,
            executed: false
        });

        emit ProposalCreated(proposalCount, _recipient, _amount, _reason, msg.sender);
        proposalCount++;
    }

    /**
     * @dev Biểu quyết một đề xuất
     * @param _proposalId ID của đề xuất
     * @param _approve Đồng ý hay từ chối (true = đồng ý, false = từ chối)
     */
    function voteProposal(uint256 _proposalId, bool _approve) external onlyEOA onlyMember {
        Proposal storage proposal = proposals[_proposalId];

        require(!proposal.executed, "Proposal already executed");
        require(!hasVoted[_proposalId][msg.sender], "Already voted");

        hasVoted[_proposalId][msg.sender] = true;

        if (_approve) {
            proposal.approvals++;
        } else {
            proposal.rejections++;
        }

        emit Voted(_proposalId, msg.sender, _approve);

        // Kiểm tra nếu có đủ 2/3 số phiếu đồng ý, thực thi đề xuất
        if (proposal.approvals >= getApprovalThreshold()) {
            executeProposal(_proposalId);
        }
    }

    /**
     * @dev Thực thi đề xuất đã được duyệt
     * @param _proposalId ID của đề xuất
     */
    function executeProposal(uint256 _proposalId) internal {
        Proposal storage proposal = proposals[_proposalId];

        require(proposal.approvals >= getApprovalThreshold(), "Not enough approvals");
        require(!proposal.executed, "Proposal already executed");

        proposal.executed = true;

        uint256 amount = proposal.amount;

        ITreeCommission treeCommission = ITreeCommission(treeCommissionContract);
        treeCommission.withdrawBPToAnotherUser(amount, proposal.recipient);

    }

    /**
     * @dev Kiểm tra số dư hiện tại của DAO
     */
    function getBalance() external view onlyEOA returns (uint256) {
        return balancesManager.getBalance(msg.sender);
    }

    /**
     * @dev Lấy thông tin chi tiết của một đề xuất
     * @param _proposalId ID của đề xuất
     */
    function getProposal(uint256 _proposalId) external view onlyEOA returns (
        address recipient, uint256 amount, string memory reason, uint256 approvals, uint256 rejections, bool executed
    ) {
        Proposal storage proposal = proposals[_proposalId];
        return (proposal.recipient, proposal.amount, proposal.reason, proposal.approvals, proposal.rejections, proposal.executed);
    }

    /**
     * @dev Sự kiện khi tạo đề xuất mới
     */
    event ProposalCreated(uint256 indexed proposalId, address indexed recipient, uint256 amount, string reason, address indexed creator);

    /**
     * @dev Sự kiện khi có thành viên biểu quyết
     */
    event Voted(uint256 indexed proposalId, address indexed voter, bool approve);

    /**
     * @dev Sự kiện khi một đề xuất được thực thi thành công
     */
    event ProposalExecuted(uint256 indexed proposalId, address indexed recipient, uint256 amount);
}

/**
 * @title eStock
 * @dev Hợp đồng ERC20 mở rộng để quản lý cổ phiếu số (eStock) mua bằng USDT.
 * Chức năng chính:
 * 1. Mua eStock bằng USDT theo tỷ giá do admin quản lý.
 * 2. Nhận lợi nhuận từ các hợp đồng khác bằng USDT.
 * 3. Rút hoa hồng USDT đã tích lũy.
 * 4. Quản lý tỷ giá và theo dõi thông tin giao dịch của user.
 */
contract eStock is ERC20, Ownable {
    IERC20 public usdtToken; // Địa chỉ hợp đồng USDT

    uint256 public exchangeRate; // Tỷ giá eStock/USDT (lưu với 6 chữ số thập phân)
    uint256 public totalUSDTReceived; // Tổng USDT đã nhận từ các nguồn khác
    uint256 public totalUSDTWithdrawn; // Tổng USDT đã rút

    mapping(address => uint256) public userUSDTBalance; // Số dư USDT của user
    mapping(address => uint256) public userUSDTWithdrawn; // Tổng USDT user đã rút

    // Sự kiện
    event ExchangeRateUpdated(uint256 newRate);
    event StockPurchased(address indexed buyer, uint256 amount, uint256 usdtSpent);
    event ProfitReceived(address indexed source, uint256 amount);
    event USDTWithdrawn(address indexed user, uint256 amount);


    address public treeCommissionContract;
    /**
     * @dev Khởi tạo hợp đồng eStock.
     * @param name Tên token
     * @param symbol Ký hiệu token
     * @param initialSupply Tổng số token ban đầu
     * @param _exchangeRate Tỷ giá eStock/USDT ban đầu
     * @param _usdtAddress Địa chỉ hợp đồng USDT
     */
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply,
        uint256 _exchangeRate,
        address _usdtAddress
    ) ERC20(name, symbol) Ownable(msg.sender) {
        _mint(msg.sender, initialSupply * (10 ** decimals())); // Phát hành token ban đầu
        exchangeRate = _exchangeRate;


        // Gán địa chỉ hợp đồng USDT cho biến usdtToken
        usdtToken = IERC20(_usdtAddress);
        
        treeCommissionContract = msg.sender;
    }

    /**
     * @dev Cập nhật tỷ giá quy đổi eStock/USDT (chỉ Owner có thể thay đổi).
     * @param newRate Tỷ giá mới.
     */
    function setExchangeRate(uint256 newRate) external onlyOwner {
        require(newRate > 0, "Rate must be greater than 0");
        exchangeRate = newRate;
        emit ExchangeRateUpdated(newRate);
    }

    /**
     * @dev Trả về tỷ giá hiện tại của eStock.
     */
    function getExchangeRate() external view returns (uint256) {
        return exchangeRate;
    }

    /**
     * @dev Người dùng mua eStock bằng USDT.
     * @param usdtAmount Số USDT gửi vào.
     * @param expectedRate Tỷ giá mong đợi để tránh thay đổi đột ngột.
     */
    function buyStock(uint256 usdtAmount, uint256 expectedRate) external {
        require(usdtAmount > 0, "Must send USDT to buy stock");
        require(expectedRate == exchangeRate, "Exchange rate changed");
        
        uint256 stockAmount = (usdtAmount * exchangeRate) / 1e6;
        require(balanceOf(owner()) >= stockAmount, "Not enough stock available");
        
        uint256 balanceBefore = usdtToken.balanceOf(address(this));
        require(usdtToken.transferFrom(msg.sender, address(this), usdtAmount), "USDT transfer failed");
        uint256 balanceAfter = usdtToken.balanceOf(address(this));
        uint256 receivedUSDT = balanceAfter - balanceBefore;
        require(receivedUSDT >= usdtAmount - 1e6 && receivedUSDT <= usdtAmount + 1e6, "Incorrect USDT transfer amount");
        
        _transfer(owner(), msg.sender, stockAmount);
        emit StockPurchased(msg.sender, stockAmount, usdtAmount);
    }

    /**
     * @dev Nhận lợi nhuận từ smart contract khác bằng USDT.
     * @param amount Số USDT nhận được.
     */
    function receiveProfitFromContract(uint256 amount) external {
        require(amount > 0, "Amount must be greater than 0");
        require(usdtToken.transferFrom(msg.sender, address(this), amount), "USDT transfer failed");
        totalUSDTReceived += amount;
        userUSDTBalance[msg.sender] += amount;
        emit ProfitReceived(msg.sender, amount);
    }

    /**
     * @dev User rút USDT từ số dư lợi nhuận.
     */
    function withdrawUSDTCommission() external {
        uint256 amount = userUSDTBalance[msg.sender];
        require(amount > 0, "No USDT balance to withdraw");
        userUSDTBalance[msg.sender] = 0;
        userUSDTWithdrawn[msg.sender] += amount;
        totalUSDTWithdrawn += amount;
        // require(usdtToken.transfer(msg.sender, amount), "USDT transfer failed");

        ITreeCommission treeCommission = ITreeCommission(treeCommissionContract);
        treeCommission.withdrawBPToAnotherUser(amount, msg.sender);

        emit USDTWithdrawn(msg.sender, amount);
    }

    /**
     * @dev Xem số dư eStock của user.
     */
    function getUserStockBalance(address user) external view returns (uint256) {
        return balanceOf(user);
    }

    /**
     * @dev Xem số dư hoa hồng USDT của user.
     */
    function getUserUSDTCommission(address user) external view returns (uint256) {
        return userUSDTBalance[user];
    }

    /**
     * @dev Xem tổng USDT user đã rút.
     */
    function getUserUSDTWithdrawn(address user) external view returns (uint256) {
        return userUSDTWithdrawn[user];
    }

    /**
     * @dev Xem tổng USDT đã nhận vào hợp đồng từ các nguồn khác.
     */
    function getTotalUSDTReceived() external view returns (uint256) {
        return totalUSDTReceived;
    }

    /**
     * @dev Xem tổng USDT đã rút khỏi hợp đồng.
     */
    function getTotalUSDTWithdrawn() external view returns (uint256) {
        return totalUSDTWithdrawn;
    }
}

contract Showroom is Ownable {
    
    /**
     * @dev Enum định nghĩa các cấp bậc của showroom
     */
    enum ShowroomTier {
        InActive,  // Chưa kích hoạt
        ShopInShop, // Quầy đặt tại cửa hàng của người khác
        Kiosk,     // Quầy nhỏ
        Retail,    // Cửa hàng
        Hub        // Trung tâm lớn
    }

    // Mapping lưu tỷ lệ hoa hồng cho showroom theo từng cấp
    mapping(ShowroomTier => uint256) public showroomCommissionRates;
    // Mapping lưu bán kính quét showroom theo từng cấp (mét)
    mapping(ShowroomTier => uint256) public scanRadius;
    // Mapping lưu bán kính an toàn cho showroom (mét)
    mapping(ShowroomTier => uint256) public safeRadius;

    /**
     * @dev Struct đại diện cho showroom
     */
    struct ShowroomNode {
        address parent;         // Showroom cha
        ShowroomTier tier;      // Cấp bậc showroom
        uint256 totalBP;        // Tổng BP của showroom
        uint256 totalMember;    // Tổng thành viên thuộc showroom
        uint256 expiryDate;     // Thời gian hết hạn showroom
        uint256 longtitude;     // Kinh độ showroom
        uint256 lattitude;      // Vĩ độ showroom
    }

    // Danh sách showroom và mapping lưu thông tin showroom
    address[] public allShowrooms;
    mapping(address => ShowroomNode) public showroomNodes;

    event ShowroomAdded(address indexed showroom, address indexed parent);

    address public treeCommissionContract;

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }

    constructor() Ownable(msg.sender) {
        
        // Khởi tạo tỷ lệ hoa hồng cho showroom theo từng cấp
        showroomCommissionRates[ShowroomTier.ShopInShop] = 25;      // 25% cho quầy nhỏ
        showroomCommissionRates[ShowroomTier.Kiosk] = 50;      // 25% cho quầy nhỏ
        showroomCommissionRates[ShowroomTier.Retail] = 75;     // 50% cho cửa hàng vừa
        showroomCommissionRates[ShowroomTier.Hub] = 100;       // 100% cho trung tâm lớn

        // Cài đặt bán kính quét showroom (mét)
        scanRadius[ShowroomTier.ShopInShop] = 50;       // 50m
        scanRadius[ShowroomTier.Kiosk] = 500;       // 500m
        scanRadius[ShowroomTier.Retail] = 2000;     // 2km
        scanRadius[ShowroomTier.Hub] = 5000;        // 5km

        // Cài đặt bán kính an toàn (mét) để showroom nhận hoa hồng khi user gần
        safeRadius[ShowroomTier.ShopInShop] = 50;        // 50m
        safeRadius[ShowroomTier.Kiosk] = 50;        // 50m
        safeRadius[ShowroomTier.Retail] = 100;       // 100m
        safeRadius[ShowroomTier.Hub] = 500;         // 500m
    }
    
    modifier onlyTreeCommission() {
        require(msg.sender == treeCommissionContract, "Not authorized");
        _;
    }

    function setTreeCommissionContract(address _treeCommission) external onlyOwner {
        treeCommissionContract = _treeCommission;
    }

    /**
     * @dev Cập nhật tỷ lệ hoa hồng showroom theo cấp bậc
     * @param tier Cấp bậc showroom
     * @param percent Phần trăm hoa hồng mới
     */
    function setShowroomCommissionRate(ShowroomTier tier, uint256 percent) public onlyOwner {
        showroomCommissionRates[tier] = percent;
    }

    /**
     * @dev Cập nhật bán kính quét showroom
     * @param tier Cấp bậc showroom
     * @param radius Bán kính mới (mét)
     */
    function setShowroomScanRadius(ShowroomTier tier, uint256 radius) public onlyOwner {
        scanRadius[tier] = radius;
    }

    /**
     * @dev Cập nhật bán kính an toàn cho showroom
     * @param tier Cấp bậc showroom
     * @param radius Bán kính an toàn mới (mét)
     */
    function setShowroomSafeRadius(ShowroomTier tier, uint256 radius) public onlyOwner {
        safeRadius[tier] = radius;
    }

    /**
     * @dev Thiết lập ngày hết hạn mới cho showroom
     * @param showroom Địa chỉ showroom
     * @param changedDays Số ngày thay đổi (cộng thêm hoặc giảm)
     */
    function setShowroomExpiryDate(address showroom, uint256 changedDays) public onlyOwner {
        showroomNodes[showroom].expiryDate = block.timestamp + (changedDays * 1 days);
    }

    /**
     * @dev Lấy tỷ lệ hoa hồng của một showroom theo cấp bậc
     * @param tier Cấp bậc showroom
     * @return Phần trăm hoa hồng hiện tại
     */
    function getShowroomCommissionRate(ShowroomTier tier) public view returns (uint256) {
        return showroomCommissionRates[tier];
    }

    /**
     * @dev Lấy bán kính quét showroom hiện tại
     * @param tier Cấp bậc showroom
     * @return Bán kính quét (mét)
     */
    function getShowroomScanRadius(ShowroomTier tier) public view returns (uint256) {
        return scanRadius[tier];
    }

    /**
     * @dev Lấy bán kính an toàn showroom hiện tại
     * @param tier Cấp bậc showroom
     * @return Bán kính an toàn (mét)
     */
    function getShowroomSafeRadius(ShowroomTier tier) public view returns (uint256) {
        return safeRadius[tier];
    }

    /**
     * @dev Thêm showroom mới vào hệ thống
     * @param newShowroom Địa chỉ showroom mới
     * @param parent Địa chỉ showroom cha
     * @param tier Cấp bậc showroom
     * @param longtitude Kinh độ của showroom
     * @param lattitude Vĩ độ của showroom
     */
    function addShowRoom(address newShowroom, address parent, ShowroomTier tier, uint256 longtitude, uint256 lattitude) public onlyOwner {
        require(showroomNodes[newShowroom].parent == address(0), "Showroom already exists");

        // Khởi tạo showroom mới với dữ liệu đầu vào
        showroomNodes[newShowroom] = ShowroomNode({
            parent: parent,
            tier: tier,
            totalBP: 0,
            totalMember: 0,
            expiryDate: block.timestamp + 365 days, // Hết hạn sau 12 tháng
            longtitude: longtitude,
            lattitude: lattitude
        });

        // Thêm showroom mới vào danh sách tất cả showroom
        allShowrooms.push(newShowroom);
    }

        /**
     * @dev Lấy danh sách showroom theo phân trang
     * @param startIndex Vị trí bắt đầu trong danh sách showroom
     * @param pageSize Số lượng showroom trả về trong một lần
     * @return Mảng các địa chỉ showroom từ vị trí startIndex với độ dài pageSize
     */
    function getShowrooms(uint256 startIndex, uint256 pageSize) external view returns (ShowroomNode[] memory) {
        require(pageSize > 0 && pageSize <= 50, "pageSize must be between 1 and 50"); // Giới hạn kích thước trang để tránh quá tải

        uint256 totalChildCount = allShowrooms.length; // Tổng số showroom trong hệ thống

        if (startIndex >= totalChildCount) {
            return new ShowroomNode[](0);// Trả về mảng rỗng nếu startIndex vượt quá tổng số showroom
        }

        // Xác định chỉ số kết thúc để cắt mảng
        uint256 endIndex = startIndex + pageSize;
        if (endIndex > totalChildCount) {
            endIndex = totalChildCount; // Nếu endIndex lớn hơn tổng showroom, đặt lại là tổng showroom
        }

        ShowroomNode[] memory paginatedChildren = new ShowroomNode[](endIndex - startIndex); // Mảng kết quả có kích thước chính xác
        uint256 resultIndex = 0;

        for (uint256 i = startIndex; i < endIndex; i++) {
            paginatedChildren[resultIndex] = showroomNodes[allShowrooms[i]]; // Thêm showroom vào mảng kết quả
            resultIndex++;
        }

        return paginatedChildren; // Trả về mảng showroom đã phân trang
    }

    function abs(int256 x) internal pure returns (uint256) {
        return x < 0 ? uint256(-x) : uint256(x);
    }


    /**
     * @dev Tính khoảng cách giữa hai điểm địa lý bằng công thức Haversine
     * @param lat1 Vĩ độ điểm 1
     * @param lon1 Kinh độ điểm 1
     * @param lat2 Vĩ độ điểm 2
     * @param lon2 Kinh độ điểm 2
     * @return Khoảng cách tính bằng mét
     */
    function calculateDistance(
        uint256 lat1,
        uint256 lon1,
        uint256 lat2,
        uint256 lon2
    ) public pure returns (uint256) {
        int256 R = 6371000 * 1e18; // Bán kính Trái Đất (mét)

        // Lấy giá trị tuyệt đối để tránh overflow
        uint256 dLat = abs(int256(lat2) - int256(lat1)) * Trigonometry.PI / (180 * 1e18);
        uint256 dLon = abs(int256(lon2) - int256(lon1)) * Trigonometry.PI / (180 * 1e18);

        uint256 lat1Rad = uint256(int256(lat1)) * Trigonometry.PI / (180 * 1e18);
        uint256 lat2Rad = uint256(int256(lat2)) * Trigonometry.PI / (180 * 1e18);

        int256 sinDLat = Trigonometry.sin(dLat / 2);
        int256 sinDLon = Trigonometry.sin(dLon / 2);
        int256 cosLat1 = Trigonometry.cos(lat1Rad);
        int256 cosLat2 = Trigonometry.cos(lat2Rad);

        int256 a = (sinDLat * sinDLat) + (cosLat1 * cosLat2 * (sinDLon * sinDLon));
        int256 c = 2 * Trigonometry.sin(uint256(a / 2)); // Đảm bảo đầu vào là uint256

        return uint256((R * c) / 1e18); // Trả về kết quả cuối
    }

    /**
     * @dev Tìm showroom gần nhất với tọa độ người dùng
     * @param userLat Vĩ độ của người dùng
     * @param userLon Kinh độ của người dùng
     * @return Địa chỉ showroom gần nhất
     */
    function findNearestShowroom(uint256 userLat, uint256 userLon) public view returns (address) {
        address nearestShowroom; // Biến lưu showroom gần nhất

        for (uint256 i = 0; i < allShowrooms.length; i++) {
            address showroom = allShowrooms[i]; // Lấy showroom hiện tại

            if (showroom == address(0) || showroomNodes[showroom].expiryDate < block.timestamp) {
                continue; // Bỏ qua showroom nếu không tồn tại hoặc đã hết hạn
            }

            ShowroomTier tier = showroomNodes[showroom].tier; // Lấy cấp bậc showroom

            if (tier == ShowroomTier.InActive) {
                continue; // Bỏ qua nếu showroom chưa kích hoạt
            }

            uint256 distance = calculateDistance(userLat, userLon, showroomNodes[showroom].lattitude, showroomNodes[showroom].longtitude); // Tính khoảng cách đến showroom

            if (distance < safeRadius[tier]) { // Nếu trong bán kính an toàn
                nearestShowroom = showroom; // Chọn showroom này
                break; // Thoát vòng lặp vì đã tìm được showroom gần nhất
            }

            if (nearestShowroom == address(0) && distance < scanRadius[tier]) {
                nearestShowroom = showroom; // Chọn showroom nếu không có showroom nào khác gần hơn
            }
        }

        return nearestShowroom; // Trả về showroom gần nhất tìm được
    }

    function plusCommision(address showroom, uint256 bp) public onlyTreeCommission returns (uint256) {
            if (showroomNodes[showroom].expiryDate <= block.timestamp) {
              return 0;
            }
            showroomNodes[showroom].totalBP += bp; // Cập nhật tổng BP showroom
            ShowroomTier tier = showroomNodes[showroom].tier; // Lấy cấp bậc showroom
            uint256 comm = showroomCommissionRates[tier]; // Lấy % hoa hồng showroom

            return comm;

    }
    function plusMember(address showroom, uint256 totalMember) public onlyTreeCommission returns (uint256) {
            if (showroomNodes[showroom].expiryDate <= block.timestamp) {
              return 0;
            }
            showroomNodes[showroom].totalMember += totalMember; // Tăng số thành viên showroom
            uint256 comm = showroomCommissionRates[showroomNodes[showroom].tier];

            return comm;

    }


    /**
     */
    function withdrawBP(uint256 amount) external onlyEOA {
        address showroom = msg.sender;
        uint256 preBalance = showroomNodes[showroom].totalBP;
        require(preBalance >= amount, "Insufficient balance");

        require(showroomNodes[showroom].expiryDate >= block.timestamp, "Showroom expired");

        ITreeCommission treeCommission = ITreeCommission(treeCommissionContract);
        treeCommission.withdrawBPToAnotherUser(amount, showroom);

    }

    /**
     * @dev Kiểm tra số dư hiện tại của Showroom
     */
    function getBalance() external view onlyEOA returns (uint256) {
        address showroom = msg.sender;
        require(showroomNodes[showroom].expiryDate >= block.timestamp, "Showroom expired");

        return showroomNodes[showroom].totalBP;
    }

}

/**
 * @title AgentLib
 * @dev Thư viện chứa các hàm xử lý Agent trong hệ thống TreeCommission
 */
library AgentLib {
    struct AgentData {
        uint256 level;
    }

    struct AgentStorage {
        mapping(address => AgentData) agents;
        uint256[] agentPercent;
    }

    /**
     * @dev Khởi tạo danh sách phần trăm hoa hồng cho các cấp Agent
     * @param self Struct chứa dữ liệu Agent
     */
    function initializeAgent(AgentStorage storage self) internal {
        self.agentPercent.push(0);   // Cấp 0: không nhận hoa hồng
        self.agentPercent.push(40);  // Cấp 1: 40%
        self.agentPercent.push(35);  // Cấp 2: 35%
        self.agentPercent.push(30);  // Cấp 3: 30%
        self.agentPercent.push(25);  // Cấp 4: 25%
    }

    /**
     * @dev Cập nhật cấp độ agent cho một người dùng
     * @param self Struct chứa dữ liệu Agent
     * @param user Địa chỉ người dùng
     * @param level Cấp độ agent mới
     */
    function setAgentLevel(AgentStorage storage self, address user, uint256 level) internal {
        require(level < self.agentPercent.length, "Invalid agent level");
        self.agents[user].level = level;
    }

    /**
     * @dev Lấy cấp độ agent của một user
     * @param self Struct chứa dữ liệu Agent
     * @param user Địa chỉ người dùng
     * @return level Cấp độ của agent
     */
    function getAgentLevel(AgentStorage storage self, address user) internal view returns (uint256) {
        return self.agents[user].level;
    }

    /**
     * @dev Tính toán phần trăm hoa hồng cho agent dựa vào cấp độ
     * @param self Struct chứa dữ liệu Agent
     * @param user Địa chỉ người dùng
     * @param defaultPercent Phần trăm mặc định nếu không phải Agent
     * @return percent Phần trăm hoa hồng tính được
     */
    function getAgentCommission(
        AgentStorage storage self,
        address user,
        uint256 defaultPercent
    ) internal view returns (uint256) {
        uint256 level = self.agents[user].level;
        return (level > 0) ? self.agentPercent[level] : defaultPercent;
    }
}

library TreeLib {

    uint256 public constant UNILEVEL_PERCENT_1 = 10; // 10% cho cấp 1
    uint256 public constant UNILEVEL_PERCENT_2_TO_5 = 5; // 5% cho cấp 2-5

    uint256 public constant PGrB_PERCENT = 2; // 2% hoa hồng nhóm cá nhân
    uint256 public constant GeB_PERCENT = 3; // 3% hoa hồng nhóm cho STL trở lên

    struct NodeInfo {
        address parent;
        address[] children;
        Rank rank;
        Status status;
        // address showroom;
    }

    struct NodeData {
        uint256 membershipExpiry;
        uint256 processedChildren;
        uint256 personalBP;
        uint256 teamBP;
        uint256 totalTeamBP;
        // uint256 personalGroupBP;
    }

    struct GenerationInfo {
        address gen1;
        address gen2;
        address gen3;
    }

    enum Rank {
        None,
        Manager,
        SeniorManager,
        TeamLeader,
        SeniorTeamLeader,
        Director,
        SeniorDirector,
        NationalDirector
    }

    enum Status {
        InActive,
        Active,
        Locked,
        Banned
    }

    /**
     * @dev Cập nhật trạng thái Active của user dựa vào điều kiện
     */


    
    function updateActiveStatus(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => NodeData) storage nodeData,
        mapping(address => uint256) storage membershipSoldThisMonth,
        mapping(address => uint256) storage productBPThisMonth,
        mapping(address => uint256) storage newMembershipInTeamThisMonth,
        address user
    ) internal returns (bool) {
        Status currentStatus = nodes[user].status;
        if (currentStatus == TreeLib.Status.Locked || currentStatus == TreeLib.Status.Banned) return false;

        if (block.timestamp > nodeData[user].membershipExpiry) {
            nodes[user].status = TreeLib.Status.Locked;
            return true;
        }

        /**
         * @dev Kiểm tra điều kiện để một user được coi là Active trong tháng.
         * Một Promoter được coi là Active nếu thỏa mãn ít nhất một trong ba điều kiện sau:
         * 1. Bán được ít nhất 1 membership mới trong tháng (membershipSoldThisMonth[user] >= 1)
         * 2. Có ít nhất 10 membership mới được kích hoạt trong team của họ trong tháng (newMembershipInTeamThisMonth[user] >= 10)
         * 3. Đạt được ít nhất 100 BP từ doanh số bán sản phẩm trong tháng (productBPThisMonth[user] >= 100)
         * 
         * Nếu một trong các điều kiện này được đáp ứng, trạng thái của user sẽ được đặt thành Status.Active.
         */
        if (
          membershipSoldThisMonth[user] >= 1
          || newMembershipInTeamThisMonth[user] >= 10
          || productBPThisMonth[user] >= 100
        ) {
            nodes[user].status = Status.Active; // Active nếu đạt đủ điều kiện
            return true;
        }

        return false;
    }


    function setGenerationRank(
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        address user,
        uint8 groupRankIndex,
        address gen1,
        address gen2,
        address gen3
    ) internal {
        generationRank[user][groupRankIndex] = GenerationInfo(gen1, gen2, gen3);
    }


     /**
     * @dev Đếm số chân active của một thành viên
     * @param nodes Mapping lưu trữ thông tin node
     * @param user Địa chỉ thành viên cần đếm
     * @return Số chân active
     */
    function countActiveLegs(mapping(address => NodeInfo) storage nodes, address user) internal view returns (uint256) {
        uint256 activeLegCount = 0;
        address[] storage children = nodes[user].children;
        for (uint256 i = 0; i < children.length; i++) {
            if (nodes[children[i]].status == Status.Active) {
                activeLegCount++;
            }
        }
        return activeLegCount;
    }

    /**
     * @dev Cập nhật cấp bậc cho một thành viên dựa trên doanh số và số chân active
     * @param nodes Mapping lưu trữ thông tin node
     * @param nodeData Mapping lưu trữ thông tin node data
     * @param nationalDirectors Mảng lưu trữ danh sách National Directors
     * @param user Địa chỉ thành viên cần cập nhật
     */
    function updateRanks(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => NodeData) storage nodeData,
        address[] storage nationalDirectors,
        address user
    ) internal {
        uint256 tgbp = nodeData[user].teamBP; // Tổng doanh số nhóm
        uint256 activeLegs = countActiveLegs(nodes, user); // Số chân active

        // Điều kiện nâng cấp bậc
        if (tgbp >= 100000 && activeLegs >= 7) {
            nodes[user].rank = Rank.NationalDirector;
            nationalDirectors.push(user);
        } else if (tgbp >= 50000 && activeLegs >= 6) {
            nodes[user].rank = Rank.SeniorDirector;
        } else if (tgbp >= 25000 && activeLegs >= 5) {
            nodes[user].rank = Rank.Director;
        } else if (tgbp >= 10000 && activeLegs >= 4) {
            nodes[user].rank = Rank.SeniorTeamLeader;
        } else if (tgbp >= 5000 && activeLegs >= 3) {
            nodes[user].rank = Rank.TeamLeader;
        } else if (tgbp >= 2500 && activeLegs >= 2) {
            nodes[user].rank = Rank.SeniorManager;
        } else if (activeLegs >= 1) {
            nodes[user].rank = Rank.Manager;
        }
    }

    /**
     * @dev Cập nhật cha Active cho tất cả các con của một user
     * @param nodes Mapping lưu trữ thông tin node
     * @param activeParentMapping Mapping để lưu cha active
     * @param user Địa chỉ thành viên cần cập nhật
     */
    function updateActiveParentMapping(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => address) storage activeParentMapping,
        address user
    ) internal {
        address[] storage children = nodes[user].children;
        for (uint256 i = 0; i < children.length; i++) {
            activeParentMapping[children[i]] = user; // Gán cha active
        }
    }

    function getGroupRank(mapping(address => NodeInfo) storage nodes, address user) internal view returns (uint8) {
        Rank rank = nodes[user].rank;
        if (rank == Rank.NationalDirector) return 3;
        if (rank == Rank.SeniorDirector) return 2;
        if (rank == Rank.Director) return 1;
        return 0; // SeniorTeamLeader và các rank thấp hơn
    }


    /**
    * @dev Kiểm tra xem một địa chỉ `_child` có phải là hậu duệ (descendant) của địa chỉ `_ancestor` hay không,
    * với điều kiện có giới hạn số tầng `totalLevel` và phân quyền truy cập kiểm tra.
    * 
    * Quyền kiểm tra hậu duệ:
    * - Người gọi hàm phải là `_ancestor` hoặc có quyền xem cây từ `_ancestor` (được lưu trữ trong `linkViewTree`).
    *
    * Nếu đã kiểm tra tối đa `totalLevel` tầng mà vẫn chưa tìm thấy `_ancestor` trong cây, hàm sẽ dừng và trả về `false`.
    * Nếu `_ancestor` được tìm thấy trong vòng `totalLevel` tầng, hàm sẽ trả về `true`.
    * 
    * @param _child Địa chỉ của thành viên cần kiểm tra (đứa con).
    * @param _ancestor Địa chỉ của người cần xác minh là tổ tiên (cha, ông bà...).
    * @param totalLevel Giới hạn số tầng cần duyệt từ `_child` lên đến `_ancestor`. Dùng để tối ưu hóa hiệu suất tìm kiếm.
    * 
    * @return bool Trả về `true` nếu `_child` là hậu duệ của `_ancestor` trong phạm vi số tầng `totalLevel`, ngược lại trả về `false`.
    */
    function isDescendant(mapping(address => NodeInfo) storage nodes, address _child, address _ancestor, uint8 totalLevel, mapping(bytes32 => bool) storage linkViewTree, bytes32[] storage allLinkViewTreeKeys) internal returns (bool) {
        // require(_ancestor == msg.sender || linkViewTree[msg.sender + _ancestor] == true, "Not permitted");

        require(_ancestor == msg.sender || linkViewTree[keccak256(abi.encodePacked(msg.sender, _ancestor))] == true, "Not permitted");

        uint8 countLevel = 0; // Khởi tạo bộ đếm tầng
        address current = _child; // Bắt đầu từ _child

        // Duyệt cây từ _child lên theo hướng cha -> con
        while (current != address(0)) {
            countLevel++; // Tăng số tầng khi di chuyển lên

            // Kiểm tra xem đã đến giới hạn tầng chưa
            if (countLevel == totalLevel) {
                break;
            }

            // Nếu tìm thấy _ancestor trong quá trình duyệt
            if (current == _ancestor) {
                return true;
            }

            // Di chuyển lên cây (cha -> con)
            current = nodes[current].parent;

            // Lưu trạng thái đã kiểm tra cây đến tầng 10 để tối ưu hóa lần kiểm tra tiếp theo
            if (countLevel % 10 == 0) {
                bytes32 keyLinkView = keccak256(abi.encodePacked(msg.sender, current));
                linkViewTree[keyLinkView] = true;
                allLinkViewTreeKeys.push(keyLinkView);
            }
        }
        return false; // Nếu không tìm thấy, trả về false
    }



    /**
     * @dev Tìm cha Active gần nhất của một user
     * - Duyệt ngược từ node hiện tại lên đến root.
     * - Nếu gặp một node Active, trả về node đó.
     * - Sử dụng `activeParentMapping` để tối ưu tốc độ tìm kiếm (O(1)).
     */
    function findActiveParent(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => address) storage activeParentMapping,
        address user
    ) internal view returns (address) {
        address current = nodes[user].parent; // Bắt đầu từ cha của user
        while (current != address(0)) { // Duyệt lên đến khi gặp root (address(0))
            if (nodes[current].status == Status.Active) return current; // Trả về node Active đầu tiên tìm thấy
            current = activeParentMapping[current]; // Di chuyển lên cha Active tiếp theo trong mapping
        }
        return address(0); // Nếu không tìm thấy cha Active nào
    }

    /**
     * @dev Kiểm tra điều kiện để một user được xem là Active
     * - Điều kiện: Personal BP >= 100 hoặc Team BP >= 500.
     * @param user Địa chỉ của user cần kiểm tra
     * @return Trả về `true` nếu user đáp ứng điều kiện, ngược lại `false`
     */
    function checkActiveCondition(mapping(address => NodeData) storage nodeData, address user) internal view returns (bool) {
        return nodeData[user].personalBP >= 100 || nodeData[user].teamBP >= 500;
    }

    /**
     * @dev Cập nhật Team BP của user dựa vào các node con
     */
    function updateTeamBP(
        mapping(address => NodeData) storage nodeData,
        mapping(address => NodeInfo) storage nodes,
        address[] storage nationalDirectors,
        address user
    ) internal {

        // To-Do: sửa lại như code po5 cũ
        uint256 totalBP = nodeData[user].personalBP; // Tổng BP từ tất cả các chân và của chính user
        uint256 totalPersonalGroupBP = 0; // Tổng BP của nhóm cá nhân

        uint256 totalChild = nodes[user].children.length; // Số lượng node con

        uint256[] memory childBPs = new uint256[](totalChild); // Mảng lưu BP từng chân
        for (uint256 i = 0; i < totalChild; i++) {
            address childUser = nodes[user].children[i]; // Lấy địa chỉ node con
            NodeInfo storage nodeChildUser = nodes[childUser]; // Lấy thông tin node con
            
            uint256 teamBP = nodeData[childUser].personalBP + nodeData[childUser].teamBP; // Lấy BP của node con

            if (teamBP <= 0) {
                continue; // Bỏ qua nếu BP = 0
            }


            // xét lại là 0 để không bị lặp lại
            nodeData[childUser].teamBP = 0;

            childBPs[i] = teamBP; // Lưu BP của chân hiện tại
            totalBP += teamBP; // Cộng vào tổng BP

            // Nếu rank của node con < SeniorTeamLeader, cộng vào tổng BP nhóm cá nhân
            if (nodeChildUser.rank < Rank.SeniorTeamLeader) {
                totalPersonalGroupBP += teamBP;
            }
        }
        
        if (totalBP > 0) {

            // Áp dụng giới hạn tối đa từ chân mạnh
            uint256 maxPercentage = (nodes[user].rank >= Rank.Director) ? 40 : 50;
            uint256 maxBPPerLeg = (totalBP * maxPercentage) / 100; // Giới hạn BP theo %
            uint256 adjustedBP = 0; // BP sau khi áp dụng giới hạn
            
            for (uint256 i = 0; i < totalChild; i++) {
                adjustedBP += (childBPs[i] > maxBPPerLeg) ? maxBPPerLeg : childBPs[i];
            }

            // Nếu có thay đổi về BP, cập nhật rank
            uint256 increaseBP = adjustedBP - nodeData[user].teamBP;
            if (increaseBP > 0) {
                nodeData[user].teamBP = adjustedBP; // Cập nhật TeamBP
                updateRanks(nodes, nodeData, nationalDirectors, user); // Cập nhật rank
            }

            nodeData[user].totalTeamBP = totalBP; // Lưu tổng BP
        }
    }

    /**
     * @dev Phân phối hoa hồng Unilevel cho các cấp
     */
     function distributeUnilevelBonus(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => address) storage activeParentMapping,
        BalancesManager balancesManager,
        address user,
        uint256 bp,
        bytes32 utxoID
    ) internal {
        address current = activeParentMapping[user]; // Bắt đầu từ cha Active của user
        uint8 level = 1; // Cấp hiện tại


        address[] memory users;
        uint256[] memory amounts;
        uint256 counBatchUpdateBalances = 0; // Biến đếm số phần tử


        while (level <= 5 && current != address(0)) { // Duyệt tối đa 5 cấp
            uint256 percent = (level == 1) ? UNILEVEL_PERCENT_1 : UNILEVEL_PERCENT_2_TO_5; // Xác định % thưởng theo cấp
            uint256 commission = (bp * percent) / 100; // Tính số tiền thưởng

            // balances[current] += commission; // Cộng thưởng vào balance của node hiện tại
            if (nodes[current].status != TreeLib.Status.Locked) {
              users[counBatchUpdateBalances] = current;
              amounts[counBatchUpdateBalances] = commission;
              counBatchUpdateBalances++;
            }

            // emit BPChanged(current, bp); // Emit sự kiện khi thay đổi BP

            current = activeParentMapping[current]; // Lên cấp tiếp theo
            level++;
        }
        balancesManager.batchUpdateBalances(utxoID, users, amounts, true);
    }
    function distributeGenerationBonus_batchUpdate(
        // mapping(address => NodeInfo) storage nodes,
        BalancesManager balancesManager,
        bytes32 utxoID,
        uint256 bp,
        address personalGroup,
        address gen1,
        address gen2,
        address gen3
      ) internal {
        

        address[] memory users;
        uint256[] memory amounts;
        uint256 counBatchUpdateBalances = 0; // Biến đếm số phần tử

        // kiểm tra lại trạng thái active
        // if (nodes[personalGroup].status == TreeLib.Status.Locked) {
        //   personalGroup = address(0);
        // }
        // if (nodes[gen1].status == TreeLib.Status.Locked) {
        //   gen1 = address(0);
        // }
        // if (nodes[gen2].status == TreeLib.Status.Locked) {
        //   gen2 = address(0);
        // }
        // if (nodes[gen3].status == TreeLib.Status.Locked) {
        //   gen3 = address(0);
        // }


        // trả cho hoa hồng personal Groups, 2%
        if (personalGroup != address(0)) {
          users[counBatchUpdateBalances] = personalGroup;
          amounts[counBatchUpdateBalances] = (bp * PGrB_PERCENT) / 100;
          counBatchUpdateBalances++;
        }

        if (gen1 != address(0)) {
            users[counBatchUpdateBalances] = gen1;
            amounts[counBatchUpdateBalances] = (bp * GeB_PERCENT) / 100;
            counBatchUpdateBalances++;
        }

        if (gen2 != address(0)) {
            users[counBatchUpdateBalances] = gen2;
            amounts[counBatchUpdateBalances] = (bp * GeB_PERCENT) / 100;
            counBatchUpdateBalances++;
        }

        if (gen3 != address(0)) {
            users[counBatchUpdateBalances] = gen3;
            amounts[counBatchUpdateBalances] = (bp * GeB_PERCENT) / 100;
            counBatchUpdateBalances++;
        }



        if (users.length > 0 ) {
          balancesManager.batchUpdateBalances(utxoID, users, amounts, true);
        }

      }
    function distributeGenerationBonus(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        mapping(address => address) storage personalGroups,
        BalancesManager balancesManager,
        address user,
        uint256 bp,
        bytes32 utxoID
      ) internal {


        // address[] memory users;
        // uint256[] memory amounts;
        // uint256 counBatchUpdateBalances = 0; // Biến đếm số phần tử

        address parent = nodes[user].parent;
        uint8 groupRankIndex = TreeLib.getGroupRank(nodes, user);

        TreeLib.Rank currentRank = nodes[user].rank;

        address personalGroup = address(0);

        address gen1 = address(0);
        address gen2 = address(0);
        address gen3 = address(0);

        if ( groupRankIndex > 0 ) {

          personalGroup = address(0);

          if (currentRank == TreeLib.Rank.Director) {
            gen2 = generationRank[parent][groupRankIndex].gen2;
            gen3 = generationRank[parent][groupRankIndex].gen3;
          } else if (currentRank == TreeLib.Rank.SeniorDirector) {
            gen3 = generationRank[parent][groupRankIndex].gen3;
          }
        } else {
          personalGroup = personalGroups[parent];

          gen1 = generationRank[parent][groupRankIndex].gen1;
          gen2 = generationRank[parent][groupRankIndex].gen2;
          gen3 = generationRank[parent][groupRankIndex].gen3;
        }

        distributeGenerationBonus_batchUpdate(balancesManager, utxoID, bp, personalGroup, gen1, gen2, gen3);
    }

    /**
     * @dev Cập nhật `generationRank` cho user
     */
    function setInheritGenerationRank(
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        address parent,
        address user,
        uint8 groupRankIndex
    ) internal {
        if (parent == address(0)) return;
        
        GenerationInfo storage parentGenInfo = generationRank[parent][groupRankIndex];


        generationRank[user][groupRankIndex] = GenerationInfo(
            parentGenInfo.gen1,
            parentGenInfo.gen2,
            parentGenInfo.gen3
        );
    }

    function distributeNationalBonus(
    //   mapping(address => NodeInfo) storage nodes,
      BalancesManager balancesManager,
      address[] storage nationalDirectors
    ) internal {

        uint256 nationalBonusPool = balancesManager.getNationalBonusPool();


        uint256 totalDirectors = nationalDirectors.length;
        require(totalDirectors > 0, "No National Directors to distribute");

        uint256 bonusPerDirector = nationalBonusPool / totalDirectors;
        require(bonusPerDirector > 0, "Insufficient pool");

        // Reset pool sau khi chia thưởng
        balancesManager.resetNationalBonusPool(nationalBonusPool);
        

        address[] memory users;
        uint256[] memory amounts;
        uint256 counBatchUpdateBalances = 0; // Biến đếm số phần tử

        for (uint256 i = 0; i < totalDirectors; i++) {
            
            // if (nodes[director].status == TreeLib.Status.Locked) {
            //   continue;
            // }
            users[counBatchUpdateBalances] = nationalDirectors[i];
            amounts[counBatchUpdateBalances] = bonusPerDirector;
            counBatchUpdateBalances++;
        }

        balancesManager.batchUpdateBalances(bytes32(0), users, amounts, true);

        // emit NationalBonusDistributed(nationalBonusPool, totalDirectors);

    }

    /**
    
    * **Lưu ý:**
    * Phù hợp với batch 24h để đồng bộ toàn bộ hệ thống.
    *
    * @dev Cập nhật `generationRank` từ `rootNode` xuống toàn bộ cây MLM.
    *      Hàm này sử dụng đệ quy để duyệt toàn bộ cây và cập nhật thế hệ nhận thưởng (`gen1`, `gen2`, `gen3`)
    *      theo hệ thống cấp bậc (`Director`, `Senior Director`, `National Director`).
    *
    * **Thuật toán xử lý:**
    * 1. Nếu `current` là `rootNode`, khởi tạo tất cả `gen1`, `gen2`, `gen3` về `address(0)`.
    * 2. Nếu `current` có cấp bậc ảnh hưởng (`Director`, `Senior Director`, `National Director`):
    *    - Nếu `National Director`: `gen1 = gen2 = gen3 = current`
    *    - Nếu `Senior Director`:  `gen1 = current`, `gen2 = current`, `gen3 = generationRank[parent].gen3`
    *    - Nếu `Director`:         `gen1 = current`, `gen2 = generationRank[parent].gen2`, `gen3 = generationRank[parent].gen3`
    * 3. Nếu `current` không có rank ảnh hưởng, kế thừa `generationRank` từ `parent`.
    * 4. Đệ quy xuống các `children` để tiếp tục cập nhật `generationRank`.
    *
    * **Điều kiện kiểm tra:**
    * - Nếu `parent == address(0)`, nghĩa là dữ liệu bị lỗi → Gọi `revert("Parent lost during reset!")`
    *   để dừng toàn bộ hệ thống nhằm tránh dữ liệu sai lệch.
    *
    * **Ví dụ về hệ thống MLM:**
    *
    * Giả sử hệ thống MLM có cấu trúc cây như sau:
    *
    * ```
    *      A (National Director)
    *      /                 \
    *    B (Director)         C (Senior Director)
    *   /     \                \
    *  D       E (Director).    F (Senior Director)
    * ```
    *
    * **Cấp bậc ảnh hưởng của mỗi node:**
    * - `A`: National Director
    * - `B`: Director
    * - `C`: Senior Director
    * - `E`: Director
    * - `D` và `F` không có rank
    *
    * **Sau khi chạy `updateGenerationRankFromRoot(A)`, dữ liệu cập nhật như sau:**
    *
    * ```
    * +---------------------+------+------+------+
    * | Node               | gen1 | gen2 | gen3 |
    * +---------------------+------+------+------+
    * | A (National Dir.)  | A    | A    | A    |
    * | B (Director)       | B    | A    | A    |
    * | C (Senior Dir.)    | C    | C    | A    |
    * | D (Không có rank)  | B    | A    | A    |
    * | E (Director)       | E    | A    | A    |
    * | F (Senior Dir.)    | F    | F    | A    |
    * +---------------------+------+------+------+
    * ```
    *
    * **Giải thích tại sao `gen2 = parent.gen2` và `gen3 = parent.gen3` với Director:**
    * - Nếu `E` là `Director`, `gen1 = E` (do chính nó là người hưởng hoa hồng đầu tiên).
    * - `gen2` của `E` phải là `A`, vì `A` là cấp cao nhất gần nhất, và điều này được kế thừa từ `gen2` của `parent`.
    * - `gen3` của `E` cũng phải là `A`, vì hệ thống MLM phải đảm bảo duy trì đúng cấp cao nhất gần nhất.
    * - Nếu dùng `gen2 = parent.gen1`, có thể gây lỗi mất cấp bậc và làm sai logic MLM.
    *

    */

    function updateGenerationRank(
        mapping(address => NodeInfo) storage nodes,
        mapping(address => mapping(uint8 => GenerationInfo)) storage generationRank,
        mapping(address => address) storage personalGroups,
        address rootNode, address current
    ) internal {

        Rank currentRank = nodes[current].rank;

        if (current == rootNode) {

          for (uint8 groupIndex = 0; groupIndex < 4; groupIndex++) {
            setGenerationRank(generationRank, current, groupIndex, address(0), address(0), address(0));
          }

        } else if (
          // currentRank == Rank.SeniorTeamLeader || 
          currentRank == Rank.Director
          || currentRank == Rank.SeniorDirector
          || currentRank == Rank.NationalDirector
        ) { // với các rank mà có ảnh hưởng , thì cần xét lại gen1, gen2, gen3

          personalGroups[current] = current;

          address parent = nodes[current].parent;
          if (parent == address(0)) {
            //   string memory logMessage = string(
            //       abi.encodePacked(
            //           "updateGenerationRank failed: Parent lost during reset, user ", Strings.toHexString(uint256(uint160(current)), 20),
            //           ", currentRank: ", Strings.toString(uint256(currentRank))
            //       )
            //   );
            //   eventLoggerManager.recordEvent("updateGenerationRank", logMessage);
              revert("Parent lost during reset!");
          }

          for (uint8 groupIndex = 0; groupIndex < 4; groupIndex++) {

            address gen1;
            address gen2;
            address gen3;

            if (currentRank == Rank.NationalDirector) {
                gen3 = current;
                gen2 = current;
                gen1 = current;
            } else if (currentRank == Rank.SeniorDirector) {
                gen3 = generationRank[parent][groupIndex].gen3;
                gen2 = current;
                gen1 = current;
            } else {
                // currentRank == Rank.Director
                gen3 = generationRank[parent][groupIndex].gen3;
                gen2 = generationRank[parent][groupIndex].gen2;
                gen1 = current;
            }

            setGenerationRank(generationRank, current, groupIndex, gen1, gen2, gen3);
          }

        } else { // dành cho các node mà không có rank ảnh hưởng đến child, thì lấy parent của node đó gán vào


          address parent = nodes[current].parent;
          if (parent == address(0)) {
            // string memory logMessage = string(
            //     abi.encodePacked(
            //         "updateGenerationRank failed: Parent lost during reset, user ", Strings.toHexString(uint256(uint160(current)), 20),
            //         ", currentRank: ", Strings.toString(uint256(currentRank))
            //     )
            // );
            // eventLoggerManager.recordEvent("updateGenerationRank", logMessage);
            revert("Parent lost during reset!");
          }

          for (uint8 groupIndex = 0; groupIndex < 4; groupIndex++) {
            // generationRank[current][groupIndex] = generationRank[parent][groupIndex];
            setInheritGenerationRank(generationRank, parent, current, groupIndex);
          }

          if (
            currentRank == Rank.SeniorTeamLeader
          ) {
            personalGroups[current] = current;
          } else {
            personalGroups[current] = parent;
          }

        }

        // Đệ quy xuống children
        address[] storage children = nodes[current].children;
        for (uint i = 0; i < children.length; i++) {
            // updateGenerationRank(nodes, rootNode, children[i]);
            updateGenerationRank(nodes, generationRank, personalGroups, rootNode, children[i]);
        }
    }

    function isValidUTXO(bytes32 utxoID) internal pure returns (bool) {
        return utxoID != bytes32(0);
    }

    function checkTransferUSDT(IERC20 usdtToken, bytes32 utxoID, uint256 usdtAmount) internal {

        if (isValidUTXO(utxoID)) {
            
        } else {

            // Kiểm tra số dư USDT trước giao dịch
            uint256 balanceBefore = usdtToken.balanceOf(address(this));

            // Yêu cầu chuyển USDT từ user vào hợp đồng
            require(usdtToken.transferFrom(msg.sender, address(this), usdtAmount), "USDT transfer failed");

            // Kiểm tra số dư USDT sau giao dịch
            uint256 balanceAfter = usdtToken.balanceOf(address(this));
            uint256 receivedUSDT = balanceAfter - balanceBefore;

            // Đảm bảo số dư USDT tăng đúng số lượng user đã gửi, với sai số ±1 USDT (đơn vị 6 chữ số thập phân)
            require(receivedUSDT >= usdtAmount - 1e6 && receivedUSDT <= usdtAmount + 1e6, "Incorrect USDT transfer amount");

        }
    }

}

/**
 * @title TreeCommission
 * @dev Hợp đồng thông minh MLM "Power of 5" triển khai kế hoạch thưởng với nhiều loại hoa hồng,
 * quản lý thành viên và xử lý batch để tối ưu hóa gas.
 */
contract TreeCommission is ITreeCommission {
    using AgentLib for AgentLib.AgentStorage;
    AgentLib.AgentStorage private agentStorage;

    using TreeLib for mapping(address => TreeLib.NodeInfo);
    using TreeLib for mapping(address => TreeLib.NodeData);
    // using TreeLib for mapping(address => TreeLib.GenerationInfo);



    // mapping(address => uint256) public agentLevel;


    /**
     * @dev Mảng lưu phần trăm hoa hồng cho các cấp bậc Agent
     */
    // uint256[] public agentPercent;

    /**
     * @dev Giá trị phần nghìn cho hoa hồng của Agent (tính theo đơn vị phần nghìn)
     */
    uint256 internal constant AGENT_FW_PERMILLE = 325; // 32.5%

    // Các phí và bonus được tính theo đơn vị USDT 1e6
    uint256 internal constant ACTIVATION_FEE = 40 * 1e6; // Phí kích hoạt $40
    uint256 internal constant ACTIVATION_BP = 10; // 10 BP khi kích hoạt

    uint256 internal constant MEMBERSHIP_FEE = 120 * 1e6; // Phí thành viên $120
    uint256 internal constant MEMBERSHIP_BP = 100; // 100 BP cho mỗi lần bán thành viên

    // Phần trăm hoa hồng cho các hạng mục khác nhau
    uint256 internal constant STOCK_COMMISSION_PERCENT = 20; // 20% cho hoa hồng bán lẻ
    uint256 internal constant DAO_COMMISSION_PERCENT = 4;    // 4% cho DAO
    uint256 internal constant RETAIL_COMMISSION_PERCENT = 20; // 20% cho hoa hồng bán lẻ
    uint256 internal constant SHOWROOM_COMMISSION_PERCENT = 1; // 1% cho showroom
    uint256 internal constant SHOWROOM_BONUS = 20; // Bonus $20 cho showroom gần nhất

    // Phần trăm hoa hồng Unilevel cho các cấp trong hệ thống MLM
    // uint256 internal constant UNILEVEL_PERCENT_1 = 10; // 10% cho cấp 1
    // uint256 internal constant UNILEVEL_PERCENT_2_TO_5 = 5; // 5% cho cấp 2-5
    // uint256 internal constant PGrB_PERCENT = 2; // 2% hoa hồng nhóm cá nhân
    // uint256 internal constant GeB_PERCENT = 3; // 3% hoa hồng nhóm cho STL trở lên

    // Giới hạn phần trăm từ một chân để tránh hiện tượng chân mạnh
    uint256 internal constant MAX_LEG_PERCENTAGE = 50; // 50% cho các cấp dưới Director
    uint256 internal constant MAX_LEG_PERCENTAGE_DIRECTOR = 40; // 40% cho Director trở lên

    uint256 internal constant NATIONAL_BONUS_POOL_PERCENT = 2; // 2% hoa hồng đổ vào pool cho RANK BASES NATIONAL BONUS POOL (2% of BP), mỗi ngày sẽ lấy ra chia cho tất cả thành viên đạt cấp National Director

    address[] internal nationalDirectors;
    // event NationalBonusDistributed(uint256 totalPool, uint256 totalDirectors);



    /**
     * @dev Struct cho VIPNode (thành viên chờ kích hoạt)
     */
    struct VIPNode {
        address parent;               // Cha của VIPNode
        uint256 membershipExpiry;     // Thời gian hết hạn membership
    }

    // Danh sách node và mapping lưu thông tin node
    address[] internal allNodes;
    // mapping(address => NodeInfo) public nodes;
    // mapping(address => NodeData) public nodeData;

    mapping(address => TreeLib.NodeInfo) private nodes;
    mapping(address => TreeLib.NodeData) private nodeData;
    

    mapping(address => address) private memberInShowroom;
    
    // Lưu số lượng membership đã bán trong tháng cho từng user
    mapping(address => uint256) internal membershipSoldThisMonth;

    // Lưu điểm BP sản phẩm trong tháng cho từng user
    mapping(address => uint256) internal productBPThisMonth;

    mapping(address => uint256) internal newMembershipInTeamHour;
    mapping(address => uint256) internal newMembershipInTeamThisMonth; // Thêm biến độc lập để ghi nhận 10 membership mới trong team

    mapping(address => address) private personalGroups; // Mapping cha hoa hồng thế hệ peronal group
    mapping(address => address) private activeParentMapping; // Mapping cha Active

    // mapping(address => TreeLib.GenerationInfo) private generationRank;
    mapping(address => mapping(uint8 => TreeLib.GenerationInfo)) private generationRank;



    // Danh sách leafNodes (node lá)
    address[] internal leafNodes;

    /**
     * @dev Struct lưu thông tin thành viên mới trong queue
     */
    struct NewMember {
        address newMember;      // Thành viên mới
        address parent;         // Cha
        uint256 longtitude;     // Kinh độ
        uint256 lattitude;      // Vĩ độ
        bytes32 utxoID;
    }

    /**
     * @dev Struct lưu thông tin giao dịch bán hàng trong queue
     */
    struct SalesRecord {
        address user;           // Người dùng
        uint256 bp;             // Số BP
        bytes32 utxoID;
    }

    // Queue cho xử lý batch: thành viên mới và giao dịch
    NewMember[] internal newMemberQueue;
    SalesRecord[] internal salesQueue;

    bool internal isBatchProcessing = false; // Cờ báo hiệu đang xử lý batch
    bool internal isLockData = false;        // Cờ báo hiệu đang khóa dữ liệu

    // Mapping và danh sách VIPNode
    mapping(address => VIPNode) internal vipNodes;
    mapping(address => address[]) internal vipNodesList;

    // Sự kiện khi thêm VIP và Promoter
    // event VIPAdded(address indexed user, address indexed parent);
    // event PromoterAdded(address indexed user, address indexed parent);

    // Các địa chỉ quan trọng trong hệ thống
    address rootNode;
    address daoNode;
    address stockNode;

    IERC20 internal usdtToken; // Token USDT sử dụng trong hệ thống
    address owner;

    event BPChanged(address indexed user, uint256 bp);


    struct SalesData {
        uint256 totalBP;
        bool exists;
    }

    mapping(address => SalesData) internal hourlySales;
    mapping(address => bool) internal hasSales; // Biến cờ độc lập để lưu bổ sung cho user kế thừa doanh số phát sinh từ nhánh dưới



    BalancesManager internal balancesManager;
    Showroom internal showroomManager;
    EventLogger internal eventLoggerManager;

    mapping(bytes32 => bool) internal linkViewTree;
    bytes32[] internal allLinkViewTreeKeys; // Danh sách lưu trữ tất cả các khóa


    /**
     * @dev Hàm khởi tạo hợp đồng thông minh TreeCommission
     * @param _usdtAddress Địa chỉ của hợp đồng token USDT
     */
    constructor(address _balanceManagerAddress, address _showroomAddress, address _eventLoggerAddress, address _rootNodeAddress, address _daoNodeAddress, address _stockNodeAddress, address _usdtAddress) {
        // Kiểm tra tính hợp lệ của MEMBERSHIP_BP (tránh lỗi do lập trình sai)
        require(MEMBERSHIP_BP * 1e6 < MEMBERSHIP_FEE, "wrong code");

        balancesManager = BalancesManager(_balanceManagerAddress);
        showroomManager = Showroom(_showroomAddress);
        eventLoggerManager = EventLogger(_eventLoggerAddress);

        // Gán địa chỉ hợp đồng USDT cho biến usdtToken
        usdtToken = IERC20(_usdtAddress);


        rootNode = _rootNodeAddress;
        daoNode = _daoNodeAddress;
        stockNode = _stockNodeAddress;

        owner = msg.sender;

        // Khởi tạo phần trăm hoa hồng cho các cấp Agent
        agentStorage.initializeAgent();

        nodes[rootNode].status = TreeLib.Status.Active;


    }
    

     /**
     * @dev Modifier `onlyOwner` giới hạn quyền truy cập cho chủ sở hữu
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Ownable: caller is not the owner"); // Kiểm tra người gọi là chủ sở hữu
        _;
    }

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Smart contracts not allowed");
        _;
    }

    /**
     * @dev Khóa dữ liệu trong hệ thống
     * - Không cho phép thêm mới, chỉnh sửa dữ liệu khi đang chạy batch.
     * - Chỉ được thực thi nếu hệ thống khi batch không chạy
     */
    function setLockData(bool isLock) external onlyOwner {
        require(!isBatchProcessing, "Batch processing is running"); // Kiểm tra đang batch

        isLockData = isLock; // Khóa dữ liệu
    }

    // function getUserStatus(address user) external view returns (uint256) {
    //     return uint256(nodes[user].status);
    // }
 
    function banUser(address user) external onlyOwner {
        nodes[user].status = TreeLib.Status.Banned;
    }


    function withdrawBPToUser(uint256 amount, address user) internal {
        uint256 preBalance = balancesManager.getBalance(msg.sender);
        require(preBalance >= amount, "Insufficient balance");

        TreeLib.Status userStatus = nodes[msg.sender].status;
        require(userStatus != TreeLib.Status.Locked && userStatus != TreeLib.Status.Banned, "Deny access");

        require(balancesManager.withdrawBP(msg.sender, amount), "Insufficient balance for withdraw");

        require(usdtToken.transfer(user, amount), "Transfer failed");

        // uint256 lastBalance = balancesManager.getBalance(msg.sender);

        // #debug tạm ẩn để ko bị warning code
        // if (lastBalance != preBalance - amount) {
        //     string memory logMessage = string(
        //         abi.encodePacked(
        //             "withdrawBP failed: last balance: ", Strings.toString(lastBalance),
        //             ", pre balance: ", Strings.toString(preBalance),
        //             ", amount: ", Strings.toString(amount)
        //         )
        //     );
        //     eventLoggerManager.recordEvent("withdrawBP", logMessage);
        // }

        // emit BPChanged(msg.sender, lastBalance);
    }
    
    // chỉ cho phép stockNode || rootNode || daoNode gọi
    function withdrawBPToAnotherUser(uint256 amount, address user) external {
        require(amount > 0, "Amount must be greater than 0");
        
        require(rootNode == msg.sender || stockNode == msg.sender || daoNode == msg.sender, "Contracts not allowed");

        withdrawBPToUser(amount, user);
    }
    function withdrawBP(uint256 amount) external {
        require(amount > 0, "Amount must be greater than 0");
        
        /*

        - Chặn smart contract gọi đến, nhưng vẫn cho phép rootNode, stockNode, daoNode
        - Trong 3 smart contract, cần thêm kiểm tra msg.sender == tx.origin để đảm bảo đúng là user gọi tới trực tiếp smart contract
        
        modifier onlyEOA() {
            require(msg.sender == tx.origin, "Smart contracts not allowed");
            _;
        }
        
        */
        require(tx.origin == msg.sender || rootNode == msg.sender || stockNode == msg.sender || daoNode == msg.sender, "Contracts not allowed");
        withdrawBPToUser(amount, msg.sender);
    }

    /**
     * @dev Cập nhật cấp độ agent cho một người dùng
     * @param user Địa chỉ người dùng
     * @param level Cấp độ agent mới
     */
    function setAgentLevel(address user, uint256 level) public onlyOwner {
        require(nodes[user].parent != address(0), "User not exists"); // Kiểm tra người dùng có tồn tại không

        agentStorage.setAgentLevel(user, level);
    }

        /**
     * @dev Xử lý hàng đợi (queue) các thành viên mới và các giao dịch mua hàng
     * - Xử lý lần lượt từng thành viên trong `newMemberQueue` bằng `_processNewMember`
     * - Xử lý từng giao dịch trong `salesQueue` bằng `_processPersonalSales`
     * - Sau khi xử lý xong, xóa toàn bộ dữ liệu trong queue
     */
    function processQueue() internal {
        require(!isBatchProcessing, "Batch update is running"); // Kiểm tra hệ thống có đang xử lý batch không

        // Xử lý các thành viên mới trong `newMemberQueue`
        for (uint256 i = 0; i < newMemberQueue.length; i++) {
            _processNewMember(
                newMemberQueue[i].newMember,
                newMemberQueue[i].parent,
                newMemberQueue[i].longtitude,
                newMemberQueue[i].lattitude,
                bytes32(0)
            );
        }
        delete newMemberQueue; // Xóa dữ liệu queue sau khi xử lý

        // Xử lý các giao dịch bán hàng cá nhân trong `salesQueue`
        for (uint256 i = 0; i < salesQueue.length; i++) {
            _processPersonalSales(salesQueue[i].user, salesQueue[i].bp, bytes32(0));
        }
        delete salesQueue; // Xóa dữ liệu queue sau khi xử lý
    }

    /**
     * @dev Ghi nhận giao dịch bán hàng cá nhân
     * - Nếu hệ thống đang batch, thêm giao dịch vào `salesQueue` để xử lý sau
     * - Nếu không, xử lý ngay lập tức bằng `processQueue` và `_processPersonalSales`
     * @param user Địa chỉ thành viên thực hiện giao dịch
     * @param bp Điểm BP của giao dịch
     */
    function recordPersonalSales(address user, uint256 bp, bytes32 utxoID) internal {
        require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống có đang khóa dữ liệu không
        if (isBatchProcessing) {
            salesQueue.push(SalesRecord(user, bp, utxoID)); // Nếu đang batch, thêm giao dịch vào queue
            return;
        }

        processQueue(); // Nếu không batch, xử lý queue trước
        _processPersonalSales(user, bp, utxoID); // Xử lý giao dịch ngay
    }


    // Ghi nhận doanh số phát sinh mỗi giờ
    function recordSales(address user, uint256 bp) internal {
        if (!hourlySales[user].exists) {
            hourlySales[user].exists = true;
        }
        hourlySales[user].totalBP += bp;
    }

    /**
     * @dev Xử lý giao dịch bán hàng cá nhân, cập nhật BP và trả hoa hồng
     * - Tính toán % hoa hồng dựa trên cấp độ (Agent hay không)
     * - Cập nhật trạng thái active nếu cần
     * - Phân phối thưởng showroom, DAO, stock
     * @param user Địa chỉ thành viên thực hiện giao dịch
     * @param bp Điểm BP của giao dịch
     */
    function _processPersonalSales(address user, uint256 bp, bytes32 utxoID) internal {

        // nếu thành viên là VIP, thì ghi nhận doanh số cho parent
        if (vipNodes[user].parent != address(0)){
            user = vipNodes[user].parent;
        }


        nodeData[user].personalBP += bp; // Cập nhật BP cá nhân
        productBPThisMonth[user] += bp; // Cập nhật BP tháng này

        uint256 commissionPercent = 0; // % hoa hồng
        uint256 newBP = bp; // BP sau khi tính toán với Agent

        // 
        // trả hoa hồng thế hệ 20% nếu ko phải agent
        // Nếu user là Agent, tính % theo cấp độ Agent
        //
        uint256 stockNodeBonus = 0;
        if (agentStorage.getAgentLevel(user) > 0) {
            commissionPercent = agentStorage.getAgentCommission(user, RETAIL_COMMISSION_PERCENT); // Lấy % theo cấp độ Agent
            newBP = (bp * AGENT_FW_PERMILLE) / 1000; // Điều chỉnh BP theo phần nghìn

            // 27.5% = 100% hoa hồng - 40% trả cho agent cấp 1 và 32.4% cho hoa hồng các tầng trên
            stockNodeBonus = (1000 - 400 - 325) * bp / 1000;
        } else {
            commissionPercent = RETAIL_COMMISSION_PERCENT; // Nếu không phải Agent, lấy % bán lẻ
            stockNodeBonus = (bp * 32) / 100;
        }

        if (nodes[user].status != TreeLib.Status.Locked) {
          balancesManager.updateBalance(user, utxoID, (bp * commissionPercent) / 100, true);
        }

        // --- end


        bool wasActive = nodes[user].status == TreeLib.Status.Active; // Kiểm tra trạng thái trước khi cập nhật
        // updateActiveStatus(user); // Cập nhật trạng thái active nếu cần
        nodes.updateActiveStatus(nodeData, membershipSoldThisMonth, productBPThisMonth, newMembershipInTeamThisMonth, user);

        // Nếu trước đó không active nhưng giờ active, cập nhật cha Active
        if (!wasActive && nodes[user].status == TreeLib.Status.Active) {
            TreeLib.updateActiveParentMapping(nodes, activeParentMapping, user);
        }

        emit BPChanged(user, bp); // Phát sự kiện thay đổi BP cho user

        // trả hoa hồng thế hệ 30% = 10 + 5 + 5 + 5 + 5
        nodes.distributeUnilevelBonus(activeParentMapping, balancesManager, user, newBP, utxoID); // Phân phối thưởng Unilevel cho tuyến trên

        recordSales(user, newBP);
        
        // hoa hồng cho nationalBonusPool 2%
        uint256 nationalBonus = (newBP * NATIONAL_BONUS_POOL_PERCENT) / 100;
        balancesManager.addNationalBonusPool(nationalBonus, utxoID);
        

        // trả hoa hồng showroom 1%
        address showroom = memberInShowroom[user]; // Lấy showroom của user
        if (showroom != address(0)) {

            uint256 comm = showroomManager.plusCommision(showroom, newBP);

            uint256 amountBP = (newBP * SHOWROOM_COMMISSION_PERCENT * comm) / 10000; // Trả hoa hồng cho showroom
            // balances[showroom] += amountBP;
            balancesManager.updateBalance(showroom, utxoID, amountBP, true);

        }
        // trả hoa hồng thế hệ 11% = 2 + 3 + 3 + 3 
        TreeLib.distributeGenerationBonus(nodes, generationRank, personalGroups, balancesManager, user, bp, utxoID);

        // hoa hồng cho DAO 4%
        balancesManager.updateBalance(daoNode, utxoID, (newBP * DAO_COMMISSION_PERCENT) / 100, true);

        // hoa hồng cho stock
        balancesManager.updateBalance(stockNode, utxoID, stockNodeBonus, true);


    }


    /**
     * @dev Thêm một VIP member vào hệ thống
     * @param newMember Địa chỉ của thành viên mới
     * @param parent Địa chỉ cha của thành viên
     */
    function addVIPMember(address newMember, address parent, bytes32 utxoID) external onlyEOA {
        require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống có đang nâng cấp không
        require(nodes[newMember].parent == address(0), "User already exists"); // Kiểm tra user đã tồn tại chưa
        require(vipNodes[newMember].parent == address(0), "User already exists in VIP"); // Kiểm tra user đã tồn tại trong VIP chưa
        // require(nodes[parent].parent != address(0), "Parent does not exist"); // Kiểm tra cha có tồn tại và đang active không
        
        // bỏ điều kiên này , để khi parent vừa mới đăng ký vẫn có thể cho user khác ở dưới được
        // require(nodes[parent].status == TreeLib.Status.Active, "Parent is not active"); // Kiểm tra cha có đang active không

        // những user muốn đăng ký dưới address root thì phải do owner tạo
        require(parent != rootNode || msg.sender == owner, "Parent not allow");
        // require(msg.value == MEMBERSHIP_FEE, "Incorrect fee"); // Kiểm tra phí membership

        TreeLib.checkTransferUSDT(usdtToken, utxoID, MEMBERSHIP_FEE);

        

        vipNodes[newMember] = VIPNode({ // Tạo một node VIP mới
            parent: parent,
            membershipExpiry: block.timestamp + 365 days // Hết hạn sau 12 tháng
        });

        vipNodesList[parent].push(newMember); // Thêm vào danh sách VIP của cha
        recordPersonalSales(newMember, MEMBERSHIP_BP, utxoID); // Ghi lại doanh số cá nhân của thành viên mới
        // emit VIPAdded(newMember, parent); // Phát sự kiện VIP mới được thêm

        balancesManager.updateBalance(stockNode, utxoID, MEMBERSHIP_FEE / 1e6 - MEMBERSHIP_BP, true);

    }

    /**
     * @dev Lấy danh sách các thành viên VIP trực thuộc một node
     * @param user Địa chỉ của node (cha)
     * @param startIndex Vị trí bắt đầu trong danh sách
     * @param pageSize Số lượng VIP trả về trong một lần
     * @return Mảng chứa địa chỉ các VIP trực thuộc
     */
    function getVIPMembers(address user, uint256 startIndex, uint256 pageSize) external onlyEOA view returns (address[] memory) {
        require(pageSize > 0 && pageSize <= 50, "pageSize must be between 1 and 50");

        uint256 totalChildCount = vipNodesList[user].length; // Tổng số VIP của user
        if (startIndex >= totalChildCount) {
            return new address[](0); // về mảng rỗng nếu startIndex vượt quá
        }

        uint256 endIndex = startIndex + pageSize;
        if (endIndex > totalChildCount) {
            endIndex = totalChildCount; // Điều chỉnh endIndex nếu vượt quá tổng
        }

        address[] memory paginatedChildren = new address[](endIndex - startIndex); // Mảng kết quả
        uint256 resultIndex = 0;

        for (uint256 i = startIndex; i < endIndex; i++) {
            paginatedChildren[resultIndex] = vipNodesList[user][i]; // Lấy VIP từ danh sách
            resultIndex++;
        }

        return paginatedChildren; // Trả về danh sách VIP đã phân trang
    }

    /**
     * @dev Thêm một thành viên Promoter mới vào hệ thống
     * @param newMember Địa chỉ thành viên mới
     * @param parent Địa chỉ cha trực tiếp
     * @param longtitude Kinh độ vị trí thành viên mới
     * @param lattitude Vĩ độ vị trí thành viên mới
     */
    function addPromoterMember(address newMember, address parent, uint256 longtitude, uint256 lattitude, bytes32 utxoID) external onlyEOA {
        require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không
        require(nodes[newMember].parent == address(0), "User already exists"); // Thành viên đã tồn tại
        require(vipNodes[newMember].parent == address(0), "User already exists in VIP"); // Thành viên đã tồn tại trong danh sách VIP
        require(nodes[parent].parent != address(0), "Parent does not exist"); // Kiểm tra cha có tồn tại và đang active không

        // những user muốn đăng ký dưới address root thì phải do owner tạo
        require(parent != rootNode || msg.sender == owner, "Parent not allow");

        // require(msg.value == ACTIVATION_FEE + MEMBERSHIP_FEE, "Incorrect fee"); // Kiểm tra phí thanh toán đủ không

        TreeLib.checkTransferUSDT(usdtToken, utxoID, ACTIVATION_FEE + MEMBERSHIP_FEE);

        // Ghi nhận doanh số cá nhân khi thêm thành viên mới
        recordPersonalSales(newMember, MEMBERSHIP_BP, utxoID);

        balancesManager.updateBalance(stockNode, utxoID, MEMBERSHIP_FEE / 1e6 - MEMBERSHIP_BP, true);

        if (isBatchProcessing) { 
            // Nếu hệ thống đang chạy batch, thêm thành viên vào queue để xử lý sau
            newMemberQueue.push(NewMember(newMember, parent, longtitude, lattitude, utxoID));
            // emit PromoterAdded(newMember, parent); // Phát sự kiện thêm thành viên
            return;
        }

        // Nếu không trong batch, xử lý ngay lập tức
        processQueue();
        _processNewMember(newMember, parent, longtitude, lattitude, utxoID); 
        // emit PromoterAdded(newMember, parent);
    }

    /**
     * @dev Nâng cấp một tài khoản từ VIP lên Promoter
     * @param user Địa chỉ tài khoản VIP cần nâng cấp
     * @param longtitude Kinh độ vị trí của thành viên
     * @param lattitude Vĩ độ vị trí của thành viên
     */
    function upgradeToPromoter(address user, uint256 longtitude, uint256 lattitude, bytes32 utxoID) external payable onlyEOA {
        require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống có đang nâng cấp không
        require(vipNodes[user].parent != address(0), "User not pending"); // Kiểm tra thành viên có trong danh sách VIP không
        // require(msg.value == ACTIVATION_FEE, "Incorrect fee"); // Kiểm tra phí nâng cấp

        require(vipNodes[user].membershipExpiry >= block.timestamp, "Membership expired"); // Kiểm tra hạn membership

        address parent = vipNodes[user].parent; // Lấy địa chỉ cha
        require(nodes[parent].parent != address(0), "Parent does not exist"); // Kiểm tra cha có tồn tại và active không

        TreeLib.checkTransferUSDT(usdtToken, utxoID, ACTIVATION_FEE);


        // Xóa thành viên khỏi danh sách VIP
        delete vipNodes[user]; 
        for (uint256 i = 0; i < vipNodesList[parent].length; i++) {
            if (vipNodesList[parent][i] == user) {
                vipNodesList[parent][i] = vipNodesList[parent][vipNodesList[parent].length - 1]; // Thay thế bằng phần tử cuối cùng
                vipNodesList[parent].pop(); // Xóa phần tử cuối
                break;
            }
        }

        if (isBatchProcessing) {
            // Nếu đang batch, thêm vào queue
            newMemberQueue.push(NewMember(user, parent, longtitude, lattitude, utxoID));
            return;
        }

        processQueue();
        _processNewMember(user, parent, longtitude, lattitude, utxoID); // Thêm vào hệ thống
    }

    /**
     * @dev Gia hạn Membership cho tài khoản Promoter
     * @param user Địa chỉ thành viên cần gia hạn
     */
    function renewMembership(address user, bytes32 utxoID) external payable onlyEOA {
        require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống đang có nâng cấp không

        if (vipNodes[user].parent == address(0)) {
          require(nodes[user].parent != address(0), "User does not exist"); // Kiểm tra tài khoản tồn tại không
          require(block.timestamp <= nodeData[user].membershipExpiry, "Membership expired, cannot renew"); // Kiểm tra hạn
        } else {
          require(nodes[user].parent == address(0), "User wrong structure");
        }
        // require(msg.value == MEMBERSHIP_FEE, "Incorrect fee"); // Kiểm tra phí

        TreeLib.checkTransferUSDT(usdtToken, utxoID, MEMBERSHIP_FEE);


        nodeData[user].membershipExpiry += 365 days; // Gia hạn thêm 12 tháng
        recordPersonalSales(user, MEMBERSHIP_BP, utxoID); // Ghi nhận doanh số cá nhân khi gia hạn

        balancesManager.updateBalance(stockNode, utxoID, MEMBERSHIP_FEE / 1e6 - MEMBERSHIP_BP, true);

    }

    /**
     * @dev Hàm nội bộ để xử lý thêm thành viên mới vào hệ thống
     * @param newMember Địa chỉ thành viên mới
     * @param parent Địa chỉ cha trực tiếp
     * @param longtitude Kinh độ vị trí thành viên mới
     * @param lattitude Vĩ độ vị trí thành viên mới
     */
    function _processNewMember(address newMember, address parent, uint256 longtitude, uint256 lattitude, bytes32 utxoID) internal {
        address showroom = showroomManager.findNearestShowroom(lattitude, longtitude); // Tìm showroom gần nhất


        // Khởi tạo node mới trong hệ thống
        nodes[newMember] = TreeLib.NodeInfo({
            // hash: keccak256(abi.encode(nodes[parent].hash, keccak256(abi.encode(newMember)))),
            parent: parent,
            children: new address[](0),// Khởi tạo mảng con rỗng
            rank: TreeLib.Rank.None,
            // showroom: showroom,
            status: TreeLib.Status.InActive
        });
        nodeData[newMember] = TreeLib.NodeData({
            processedChildren: 0,
            personalBP: 0,
            // personalGroupBP: 0,
            teamBP: 0,
            totalTeamBP: 0,
            membershipExpiry: block.timestamp + 365 days // Hạn 12 tháng
        });


        balancesManager.initUser(newMember, longtitude, lattitude);
        if (showroom != address(0)) {
            memberInShowroom[newMember] = showroom;
        }


        allNodes.push(newMember); // Thêm node vào danh sách tất cả nodes
        nodes[parent].children.push(newMember); // Thêm vào danh sách con của cha
        membershipSoldThisMonth[parent] += 1; // Cập nhật số membership bán được trong tháng

        // newMembershipInTeamThisMonth[parent] += 1;
        newMembershipInTeamHour[parent] += 1; // Tăng giá trị mỗi giờ


        // Gọi ViewTree để lưu quan hệ
        // ViewTree viewTree = ViewTree(viewTreeContract);
        // viewTree.addChild(parent, newMember);


        // if (!isInNewParents(parent)) {
        //     newParents.push(parent); // Nếu cha chưa có trong danh sách newParents thì thêm vào
        // }

        activeParentMapping[newMember] = nodes[parent].status == TreeLib.Status.Active ? parent : TreeLib.findActiveParent(nodes, activeParentMapping, parent); // Cập nhật cha Active

        leafNodes.push(newMember); // Thêm vào danh sách nút lá

        balancesManager.updateBalance(parent, utxoID, ACTIVATION_BP, true); // Trả hoa hồng kích hoạt $10 cho parent

        if (showroom != address(0)) {
            uint256 comm = showroomManager.plusMember(showroom, 1);
            balancesManager.updateBalance(showroom, utxoID, (SHOWROOM_BONUS * comm) / 100, true); // Trả hoa hồng showroom

        }

        // balances[stockNode] += ACTIVATION_FEE - (SHOWROOM_BONUS + ACTIVATION_BP); // Trả hoa hồng cho stock
        balancesManager.updateBalance(stockNode, utxoID, ACTIVATION_FEE / 1e6 - (SHOWROOM_BONUS + ACTIVATION_BP), true);
    }

    function isVIP(address user) external view onlyEOA returns (bool) {
      return (nodes[user].parent != address(0) || vipNodes[user].parent != address(0));
    }

    function buyProduct(bytes32 orderID) external onlyEOA {
        require(isLockData == false, "System upgrade"); // Kiểm tra hệ thống có đang nâng cấp không
        require(orderID != bytes32(0), "wrong order ID"); // Kiểm tra hệ thống có đang nâng cấp không
        
        // gọi qua smart contract ECOM để lấy thông tin từ orderID
        uint256 amount;
        uint256 bp;
        address parent;
        bool isVIPorPromoter = false;

        bytes32 utxoID;
        // gọi qua smart contract

        // -end

        uint256 commission = amount / 1e6 - bp;
        require(commission > 0, "Wrong commission");

        require(parent != address(0), "Wrong amount");
        require(amount > 0, "Wrong amount");

        address user = msg.sender;

        // nếu khi mua là VIP hoặc Promoter
        if (isVIPorPromoter) {
          require(nodes[user].parent != address(0) || vipNodes[user].parent != address(0), "User already exists in VIP or Promoter"); // Kiểm tra user đã tồn tại trong VIP chưa
        }

        if (nodes[user].parent == address(0)) {// nếu user ko phải là Promoter, thì doanh số tính cho parent
          // tính doanh số cho parent
          user = parent;
          require(nodes[parent].parent != address(0), "Parent is not exists"); // Kiểm tra cha có đang active không
        } else {
          require(nodes[user].status == TreeLib.Status.Active, "User is not active"); // Kiểm tra cha có đang active không
          require(nodes[user].parent == parent, "Parent not match");

        }

        TreeLib.checkTransferUSDT(usdtToken, utxoID, amount);

        recordPersonalSales(user, bp, utxoID); // Ghi lại doanh số cá nhân của thành viên mới

        balancesManager.updateBalance(rootNode, utxoID, commission, true);

    }

    // /**
    //  * @dev Kiểm tra xem một cha có trong danh sách newParents không
    //  * @param parent Địa chỉ cha cần kiểm tra
    //  * @return true nếu có, false nếu không
    //  */
    // function isInNewParents(address parent) internal view returns (bool) {
    //     for (uint256 i = 0; i < newParents.length; i++) {
    //         if (newParents[i] == parent) return true;
    //     }
    //     return false;
    // }


    // Kiểm tra xem một node có thuộc nhánh của node cha bằng Merkle Proof
    // proof sẽ là hash ( address của các nút trung gian )
    // function isDescendant(
    //     address _child,
    //     address _ancestor,
    //     bytes32[] memory proof
    // ) public view returns (bool) {
    //     bytes32 currentHash = nodes[_child].hash;

    //     for (uint256 i = 0; i < proof.length; i++) {
    //       // bổ sung kiểm tra ngẫu nhiên 1 node bất kỳ để đảm bảo ko bị làm giả proof
    //         currentHash = keccak256(abi.encode(currentHash, proof[i]));
    //     }
    //     return currentHash == nodes[_ancestor].hash;

    // }


    function getPromoterInfo() external onlyEOA view returns (TreeLib.NodeInfo memory, TreeLib.NodeData memory) {
        // chỉ cho phép ViewTree gọi
        // require(msg.sender == viewTreeContract, "Unauthorized caller");
        address user = msg.sender;
        require(nodes[user].parent != address(0), "User does not exist");
        return (nodes[user], nodeData[user]);
    }

    function getVIPInfo() external onlyEOA view returns (VIPNode memory) {
        // chỉ cho phép ViewTree gọi
        // require(msg.sender == viewTreeContract, "Unauthorized caller");
        address user = msg.sender;
        require(vipNodes[user].parent != address(0), "User does not exist");
        return vipNodes[user];
    }

    /**
     * @dev Lấy danh sách con trực tiếp của một user bao gồm cả con ảo, phân trang
     * @param user Địa chỉ thành viên cần lấy danh sách con
     * @param startIndex Vị trí bắt đầu
     * @param pageSize Số lượng trả về
     * @return Mảng địa chỉ con
     */
    function getChildren(address user, uint8 totalLevel, uint256 startIndex, uint256 pageSize) external onlyEOA returns (TreeLib.NodeInfo[] memory, TreeLib.NodeData[] memory) {
        // chỉ cho phép ViewTree gọi
        // require(msg.sender == viewTreeContract, "Unauthorized caller");
        require(TreeLib.isDescendant(nodes, user, msg.sender, totalLevel, linkViewTree, allLinkViewTreeKeys), "Unauthorized caller");
        require(startIndex < nodes[user].children.length, "Invalid start index");

        uint256 totalChildren = nodes[user].children.length;

        if (startIndex >= totalChildren) return (new TreeLib.NodeInfo[](0), new TreeLib.NodeData[](0));// Trả về mảng rỗng nếu vượt giới hạn


        uint256 actualPageSize = (startIndex + pageSize > totalChildren) ? (totalChildren - startIndex) : pageSize;

        TreeLib.NodeInfo[] memory childrenInfo = new TreeLib.NodeInfo[](actualPageSize);
        TreeLib.NodeData[] memory childrenData = new TreeLib.NodeData[](actualPageSize);

        for (uint256 i = 0; i < actualPageSize; i++) {
            address child = nodes[user].children[startIndex + i];
            childrenInfo[i] = nodes[child];
            childrenData[i] = nodeData[child];
        }

        return (childrenInfo, childrenData);
    }

        /**
     * @dev Cập nhật danh sách các node lá (leafNodes)
     * - Node lá là node không có bất kỳ node con nào.
     * - Quét toàn bộ danh sách `leafNodes` hiện tại.
     * - Loại bỏ những node không còn là node lá (tức là đã có con).
     * - Cập nhật lại danh sách `leafNodes` để phản ánh chính xác trạng thái hiện tại.
     */
    function updateLeafNodes() internal {
        address[] memory updatedLeafNodes = new address[](leafNodes.length); // Khởi tạo mảng tạm để lưu node lá
        uint256 count = 0; // Biến đếm số lượng node lá

        // Duyệt qua toàn bộ node lá hiện tại
        for (uint256 i = 0; i < leafNodes.length; i++) {
            // Kiểm tra xem node này có con không
            if (nodes[leafNodes[i]].children.length == 0) {
                updatedLeafNodes[count] = leafNodes[i]; // Giữ lại node là leaf
                count++;
            }
        }

        // Cập nhật lại danh sách `leafNodes` với kích thước mới
        assembly {
            mstore(updatedLeafNodes, count) // Thiết lập kích thước mới cho mảng
        }
        leafNodes = updatedLeafNodes; // Gán lại `leafNodes` sau khi cập nhật
    }

    /**
     * @dev Xử lý đệ quy để cập nhật TeamBP và trạng thái Active cho các cấp cha.
     * - Khi một node con được xử lý xong, tăng bộ đếm processedChildren của parent.
     * - Nếu parent có phát sinh doanh số hoặc có node con phát sinh doanh số,
     *   sẽ gán cờ hasSales cho grandParent để đảm bảo doanh số được cập nhật xuyên suốt các cấp.
     * - Nếu grandParent đã xử lý hết tất cả các node con, thực hiện updateTeamBP và gọi tiếp processParentRecursively.
     * - Tiếp tục đệ quy cho đến khi đạt đến rootNode.
     * @param parent Địa chỉ của node cha hiện tại cần xử lý.
     */
    function processParentRecursively(address parent) internal {
        address grandParent = nodes[parent].parent; // Lấy cha của node hiện tại

        if (grandParent == address(0)) return; // Dừng nếu đã đến root

        nodeData[grandParent].processedChildren += 1; // Tăng bộ đếm số con đã xử lý

        if (
          hasSales[grandParent] != true // kiểm tra nếu chưa được gán trước
          && (hourlySales[parent].exists || hasSales[parent])
        ) { 
            hasSales[grandParent] = true; // Gán cờ cho parent
        }
        delete hourlySales[parent];
        delete hasSales[parent];

        if (newMembershipInTeamHour[parent] > 0) { 
            newMembershipInTeamHour[grandParent] += newMembershipInTeamHour[parent]; // Ghi nhận membership mới
            newMembershipInTeamThisMonth[grandParent] += newMembershipInTeamHour[parent]; // Ghi nhận membership mới

            delete newMembershipInTeamHour[parent]; // Reset sau khi cộng
        }

        if (nodeData[grandParent].processedChildren == nodes[grandParent].children.length) {
            nodeData[grandParent].processedChildren = 0; // Reset bộ đếm
            
            if (hasSales[grandParent]) {
              nodeData.updateTeamBP(nodes, nationalDirectors, grandParent); // Cập nhật TeamBP cho cha
            }

            processParentRecursively(grandParent); // Đệ quy lên cấp cao hơn
        }
    }

    /**
     * @dev Xử lý TeamBP và trạng thái Active theo lô (batch)
     * - Duyệt qua các leafNodes theo batch để tránh hết gas.
     * - Cập nhật TeamBP và Active Status cho từng node lá, sau đó đệ quy lên các cấp cha.
     * - Nếu node có phát sinh doanh số (nằm trong hourlySales hoặc hasSales),
     *   sẽ gán cờ hasSales cho parent để đảm bảo cập nhật TeamBP từ node lá lên root.
     * - Khi một parent đã xử lý hết tất cả node con, thực hiện updateTeamBP cho parent
     *   và gọi đệ quy processParentRecursively để tiếp tục cập nhật cho các cấp cha cao hơn.
     * @param startIndex Vị trí bắt đầu trong danh sách leafNodes.
     * @param batchSize Số lượng leafNodes xử lý trong một batch.
     * @return nextIndex Vị trí tiếp theo để tiếp tục xử lý (hoặc 0 nếu xong).
     */
    function processTeamBPAndActive(uint256 startIndex, uint256 batchSize) public onlyOwner  returns (uint256 nextIndex) {
        require(startIndex < leafNodes.length, "Invalid start index");
        require(batchSize > 0, "Batch size must be greater than 0");

        uint256 originalLeafCount = leafNodes.length; // Lưu số lượng node lá ban đầu

        // Giới hạn batchSize nếu vượt quá số lượng còn lại
        if (batchSize > originalLeafCount - startIndex) {
            batchSize = originalLeafCount - startIndex;
        }

        uint256 count = 0;

        while (count < batchSize && startIndex < originalLeafCount) {
            address user = leafNodes[startIndex];

            if (user == address(0) || user == rootNode) {
                return 0; // Trả về 0 nếu node không hợp lệ
            }

            // updateActiveStatus(user); // Cập nhật trạng thái active cho node
            nodes.updateActiveStatus(nodeData, membershipSoldThisMonth, productBPThisMonth, newMembershipInTeamThisMonth, user);

            address parent = nodes[user].parent; // Lấy cha của node
            if (parent != address(0)) {
                nodeData[parent].processedChildren += 1; // Tăng bộ đếm số con đã xử lý

                if (
                  hasSales[parent] != true // kiểm tra nếu chưa được gán trước
                  && (hourlySales[user].exists || hasSales[user])) { 
                    hasSales[parent] = true; // Gán cờ cho parent
                }
                
                delete hourlySales[user];
                delete hasSales[user];

                if (newMembershipInTeamHour[user] > 0) { 
                    newMembershipInTeamHour[parent] += newMembershipInTeamHour[user]; // Ghi nhận membership mới
                    newMembershipInTeamThisMonth[parent] += newMembershipInTeamHour[user]; // Ghi nhận membership mới
                    delete newMembershipInTeamHour[user]; // Reset sau khi cộng
                }

                // Nếu cha đã xử lý hết các node con, cập nhật TeamBP và gọi đệ quy
                if (nodeData[parent].processedChildren == nodes[parent].children.length) {
                    nodeData[parent].processedChildren = 0;

                    if (hasSales[parent]) {
                      nodeData.updateTeamBP(nodes, nationalDirectors, parent); // Cập nhật TeamBP cho cha
                    }
                    processParentRecursively(parent); // Gọi đệ quy lên cấp cha
                }

                // Nếu cha chưa active, kiểm tra điều kiện và cập nhật nếu cần
                if (
                  hasSales[parent]
                  && nodes[parent].status != TreeLib.Status.Active
                  && TreeLib.checkActiveCondition(nodeData, parent)
                ) {
                    nodes[parent].status = TreeLib.Status.Active;
                    // updateActiveParentMapping(parent); // Cập nhật cha Active
                    TreeLib.updateActiveParentMapping(nodes, activeParentMapping, parent); // Cập nhật cha Active
                }
            }

            startIndex++; // Chuyển sang leafNode tiếp theo
            count++;
        }

        // Trả về index tiếp theo để tiếp tục hoặc 0 nếu đã xử lý xong
        return (startIndex < originalLeafCount) ? startIndex + 1 : 0;
    }

    // trả thưởng cho hoa hồng RANK BASES NATIONAL BONUS POOL (2% of BP)
    function distributeNationalBonus() external onlyOwner {
        TreeLib.distributeNationalBonus(balancesManager, nationalDirectors);
    }
    function getAddress() external view onlyOwner returns (address, address, address) {
         return ( daoNode, stockNode,rootNode);
    }


    /*
      Dùng bên ngoài gọi vào hàm mỗi 24h
    */
    function dailyUpdateGenerationRank() external onlyOwner {
         nodes.updateGenerationRank(generationRank, personalGroups, rootNode, rootNode);
    }

    

        /**
     * @dev Xử lý batch mỗi giờ để cập nhật trạng thái và tính toán TeamBP
     * - Khóa dữ liệu trong quá trình xử lý.
     * - Cập nhật trạng thái Active cho các `newParents` (các cha có thành viên mới).
     * - Phân phối hoa hồng Unilevel cho các `newParents`.
     * - Cập nhật danh sách leafNodes.
     * - Xử lý toàn bộ TeamBP bằng cách duyệt tất cả leafNodes theo batch.
     * - Sau khi hoàn tất, mở khóa dữ liệu và xử lý các giao dịch chờ.
     * - Reset danh sách `newParents` để chuẩn bị cho batch tiếp theo.
     */
    function hourlyBatchProcessing() external onlyOwner {
        require(isLockData == false, "System upgrade"); // Kiểm tra xem hệ thống có đang khóa dữ liệu không
        require(!isBatchProcessing, "Already processing"); // Kiểm tra nếu đã có một batch đang chạy
        isBatchProcessing = true; // Bắt đầu quá trình batch

        // // Cập nhật trạng thái Active và phân phối hoa hồng cho cha mới
        // for (uint256 i = 0; i < newParents.length; i++) {
        //     address user = newParents[i];
        //     updateActiveStatus(user); // Cập nhật trạng thái Active của user

        //     distributeUnilevelBonus(user, nodeData[newParents[i]].personalBP); // Phân phối hoa hồng Unilevel
        // }

        updateLeafNodes(); // Cập nhật danh sách các leafNodes mới

        // Xử lý toàn bộ TeamBP bằng batch để tiết kiệm gas
        uint256 batchSize = 30; // Kích thước mỗi batch
        uint256 startIndex = 0; // Bắt đầu từ leafNode đầu tiên
        while (startIndex < leafNodes.length) { // Duyệt qua tất cả leafNodes
            uint256 nextIndex = processTeamBPAndActive(startIndex, batchSize); // Xử lý batch
            if (nextIndex == 0) {
                break; // Dừng nếu không còn leafNodes để xử lý
            }
            startIndex = nextIndex; // Chuyển sang batch tiếp theo
        }

        isBatchProcessing = false; // Kết thúc quá trình batch
        processQueue(); // Xử lý các giao dịch chờ trong queue

        // delete newParents; // Xóa danh sách cha mới sau khi đã xử lý
    }


    /**
     * @dev Xử lý batch mỗi tháng để reset dữ liệu và cập nhật trạng thái Active
     * - Chỉ được gọi sau khi đã chạy `hourlyBatchProcessing` để đảm bảo số liệu chính xác.
     * - Duyệt qua tất cả các node trong hệ thống theo từng batch.
     * - Kiểm tra điều kiện Active của từng user.
     * - Nếu không đạt điều kiện, chuyển trạng thái về InActive.
     * - Reset dữ liệu của tháng: số membership bán và BP sản phẩm.
     * @param startIndex Vị trí bắt đầu trong danh sách allNodes
     * @param batchSize Số lượng node xử lý trong mỗi batch
     */
    function resetMonthlyData(uint256 startIndex, uint256 batchSize) external onlyOwner {
        require(startIndex < allNodes.length, "Invalid start index"); // Kiểm tra vị trí bắt đầu hợp lệ


        delete nationalDirectors;

        uint256 endIndex = startIndex + batchSize > allNodes.length ? allNodes.length : startIndex + batchSize; // Xác định vị trí kết thúc

        for (uint256 i = startIndex; i < endIndex; i++) { // Duyệt qua các node trong batch
            address user = allNodes[i];

            bool isActive = false; // Biến kiểm tra trạng thái Active
            // Kiểm tra các điều kiện để Active
            if (membershipSoldThisMonth[user] >= 1
                || newMembershipInTeamThisMonth[user] >= 10
                || productBPThisMonth[user] >= 100) {
                isActive = true;
            }

            if (!isActive) { // Nếu không đạt điều kiện Active
                nodes[user].status = TreeLib.Status.InActive; // Chuyển về InActive

                // updateRanks(user); // Cập nhật lại Rank
                TreeLib.updateRanks(nodes, nodeData, nationalDirectors, user); // Cập nhật lại Rank

            } else {
                // updateActiveParentMapping(user); // Cập nhật lại cha Active
                TreeLib.updateActiveParentMapping(nodes, activeParentMapping, user);

            }

            // Reset dữ liệu tháng
            delete membershipSoldThisMonth[user];
            delete newMembershipInTeamThisMonth[user];
            delete productBPThisMonth[user];
        }

        
        for (uint256 i = 0; i < allLinkViewTreeKeys.length; i++) {
            delete linkViewTree[allLinkViewTreeKeys[i]];
        }
        
        delete allLinkViewTreeKeys;

    }

}
